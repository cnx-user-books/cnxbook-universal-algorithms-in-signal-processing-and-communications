<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:bib="http://bibtexml.sf.net/">
  <title>Beyond lossless compression</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m46226</md:content-id>
  <md:title>Beyond lossless compression</md:title>
  <md:abstract/>
  <md:uuid>23eda591-1b49-4cd9-8e09-5c43f29f6b35</md:uuid>
</metadata>

<content>
    <section id="uid1">
      <title>Universal lossy compression</title>
      <para id="id62167">Consider <m:math overflow="scroll"><m:mrow><m:mi>x</m:mi><m:mo>∈</m:mo><m:msup><m:mi>α</m:mi><m:mi>n</m:mi></m:msup></m:mrow></m:math>. The goal of lossy compression <link target-id="bid0"/> is to describe <m:math overflow="scroll"><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover></m:math>,
also of length <m:math overflow="scroll"><m:mi>n</m:mi></m:math> but possibly defined over another reconstruction alphabet
<m:math overflow="scroll"><m:mrow><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mo>≠</m:mo><m:mi>α</m:mi></m:mrow></m:math>, such that the description requires few bits and the distortion</para>
      <equation id="uid2">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mover accent="true">
              <m:mi>d</m:mi>
              <m:mo>¯</m:mo>
            </m:mover>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>x</m:mi>
              <m:mo>,</m:mo>
              <m:mover accent="true">
                <m:mi>x</m:mi>
                <m:mo>ˆ</m:mo>
              </m:mover>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mfrac>
              <m:mn>1</m:mn>
              <m:mi>n</m:mi>
            </m:mfrac>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>n</m:mi>
            </m:munderover>
            <m:mi>d</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msub>
                <m:mi>x</m:mi>
                <m:mi>i</m:mi>
              </m:msub>
              <m:mo>,</m:mo>
              <m:msub>
                <m:mover accent="true">
                  <m:mi>x</m:mi>
                  <m:mo>ˆ</m:mo>
                </m:mover>
                <m:mi>i</m:mi>
              </m:msub>
              <m:mo>)</m:mo>
            </m:mrow>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id62670">is small, where <m:math overflow="scroll"><m:mrow><m:mi>d</m:mi><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>,</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:math> is some distortion metric.
It is well known that for every <m:math overflow="scroll"><m:mrow><m:mi>d</m:mi><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>,</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:math> and distortion level <m:math overflow="scroll"><m:mi>D</m:mi></m:math> there is a minimum rate <m:math overflow="scroll"><m:mrow><m:mi>R</m:mi><m:mo>(</m:mo><m:mi>D</m:mi><m:mo>)</m:mo></m:mrow></m:math>,
such that <m:math overflow="scroll"><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> can be described at rate <m:math overflow="scroll"><m:mrow><m:mi>R</m:mi><m:mo>(</m:mo><m:mi>D</m:mi><m:mo>)</m:mo></m:mrow></m:math>. The rate <m:math overflow="scroll"><m:mrow><m:mi>R</m:mi><m:mo>(</m:mo><m:mi>D</m:mi><m:mo>)</m:mo></m:mrow></m:math> is known as the rate distortion
(RD) function, it is the fundamental information theoretic limit of lossy
compression <link target-id="bid0"/>, <link target-id="bid1"/>.</para>
      <para id="id62974">The invention of lossy compression algorithms has been a challenging problem for decades.
Despite numerous applications
such as image compression <link target-id="bid2"/>, <link target-id="bid3"/>, video
compression <link target-id="bid4"/>, and speech coding <link target-id="bid5"/>, <link target-id="bid6"/>, <link target-id="bid7"/>,
there is a significant gap between theory and practice, and these practical lossy compressors
do not achieve the RD function.
On the other hand, theoretical constructions that achieve the RD function are impractical.</para>
      <para id="id63014">A promising recent algorithm by Jalali and Weissman <link target-id="bid8"/>
is universal in the limit of infinite runtime.
Its RD performance is reasonable even with modest runtime.
The main idea is that the distortion version <m:math overflow="scroll"><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> of the input <m:math overflow="scroll"><m:mi>x</m:mi></m:math> can be computed as follows,</para>
      <equation id="uid3">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mover accent="true">
              <m:mi>x</m:mi>
              <m:mo>ˆ</m:mo>
            </m:mover>
            <m:mo>=</m:mo>
            <m:munder>
              <m:mrow>
                <m:mo form="prefix">arg</m:mo>
                <m:mo movablelimits="true" form="prefix">min</m:mo>
              </m:mrow>
              <m:mrow>
                <m:msup>
                  <m:mi>w</m:mi>
                  <m:mi>n</m:mi>
                </m:msup>
                <m:mo>∈</m:mo>
                <m:msup>
                  <m:mi>α</m:mi>
                  <m:mi>n</m:mi>
                </m:msup>
              </m:mrow>
            </m:munder>
            <m:mrow>
              <m:mo>{</m:mo>
              <m:msub>
                <m:mi>H</m:mi>
                <m:mi>k</m:mi>
              </m:msub>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msup>
                  <m:mi>w</m:mi>
                  <m:mi>n</m:mi>
                </m:msup>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>-</m:mo>
              <m:mi>β</m:mi>
              <m:mover accent="true">
                <m:mi>d</m:mi>
                <m:mo>¯</m:mo>
              </m:mover>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msup>
                  <m:mi>x</m:mi>
                  <m:mi>n</m:mi>
                </m:msup>
                <m:mo>,</m:mo>
                <m:msup>
                  <m:mi>w</m:mi>
                  <m:mi>n</m:mi>
                </m:msup>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>}</m:mo>
            </m:mrow>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id63166">where <m:math overflow="scroll"><m:mrow><m:mi>β</m:mi><m:mo>&lt;</m:mo><m:mn>0</m:mn></m:mrow></m:math> is the slope at the particular point of interest in the RD function,
and <m:math overflow="scroll"><m:mrow><m:msub><m:mi>H</m:mi><m:mi>k</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow></m:mrow></m:math> is the <emphasis effect="italics">empirical conditional entropy</emphasis> of order <m:math overflow="scroll"><m:mi>k</m:mi></m:math>,</para>
      <equation id="uid4">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>H</m:mi>
              <m:mi>k</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>n</m:mi>
              </m:msup>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>≜</m:mo>
            <m:mo>-</m:mo>
            <m:mfrac>
              <m:mn>1</m:mn>
              <m:mi>n</m:mi>
            </m:mfrac>
            <m:munder>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>a</m:mi>
                <m:mo>,</m:mo>
                <m:msup>
                  <m:mi>u</m:mi>
                  <m:mi>k</m:mi>
                </m:msup>
              </m:mrow>
            </m:munder>
            <m:msub>
              <m:mi>n</m:mi>
              <m:mi>w</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>u</m:mi>
                <m:mi>k</m:mi>
              </m:msup>
              <m:mo>,</m:mo>
              <m:mi>a</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo form="prefix">log</m:mo>
            <m:mfenced separators="" open="(" close=")">
              <m:mfrac>
                <m:mrow>
                  <m:msub>
                    <m:mi>n</m:mi>
                    <m:mi>w</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>u</m:mi>
                      <m:mi>k</m:mi>
                    </m:msup>
                    <m:mo>,</m:mo>
                    <m:mi>a</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
                <m:mrow>
                  <m:msub>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>a</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                      <m:mo>∈</m:mo>
                      <m:mi>α</m:mi>
                    </m:mrow>
                  </m:msub>
                  <m:msub>
                    <m:mi>n</m:mi>
                    <m:mi>w</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>u</m:mi>
                      <m:mi>k</m:mi>
                    </m:msup>
                    <m:mo>,</m:mo>
                    <m:msup>
                      <m:mi>a</m:mi>
                      <m:mo>'</m:mo>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mfrac>
            </m:mfenced>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id63405">where <m:math overflow="scroll"><m:msup><m:mi>u</m:mi><m:mi>k</m:mi></m:msup></m:math> is a context of order <m:math overflow="scroll"><m:mi>k</m:mi></m:math>, and as before <m:math overflow="scroll"><m:mrow><m:msub><m:mi>n</m:mi><m:mi>w</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mi>u</m:mi><m:mi>k</m:mi></m:msup><m:mo>,</m:mo><m:mi>a</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math> is the number of times that the
symbol <m:math overflow="scroll"><m:mi>a</m:mi></m:math> appears following a context <m:math overflow="scroll"><m:msup><m:mi>u</m:mi><m:mi>k</m:mi></m:msup></m:math> in <m:math overflow="scroll"><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup></m:math>.
Jalali and Weissman proved <link target-id="bid9"/>
that when <m:math overflow="scroll"><m:mrow><m:mi>k</m:mi><m:mo>=</m:mo><m:mi>o</m:mi><m:mo>(</m:mo><m:mo form="prefix">log</m:mo><m:mo>(</m:mo><m:mi>n</m:mi><m:mo>)</m:mo><m:mo>)</m:mo></m:mrow></m:math>, the RD pair <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:msub><m:mi>H</m:mi><m:mi>k</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow><m:mo>,</m:mo><m:mover accent="true"><m:mi>d</m:mi><m:mo>¯</m:mo></m:mover><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup><m:mo>,</m:mo><m:msup><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow><m:mo>)</m:mo></m:mrow></m:math>
converges to the RD function asymptotically in <m:math overflow="scroll"><m:mi>n</m:mi></m:math>.
Therefore, an excellent lossy compression technique is to compute <m:math overflow="scroll"><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> and then compress it.
Moreover, this compression can be universal. In particular, the choice of context order <m:math overflow="scroll"><m:mrow><m:mi>k</m:mi><m:mo>=</m:mo><m:mi>o</m:mi><m:mo>(</m:mo><m:mo form="prefix">log</m:mo><m:mo>(</m:mo><m:mi>n</m:mi><m:mo>)</m:mo><m:mo>)</m:mo></m:mrow></m:math> ensures that
universal compressors for context tress sources can emulate the coding length of the empirical conditional entropy
<m:math overflow="scroll"><m:mrow><m:msub><m:mover accent="true"><m:mi>H</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>k</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow></m:mrow></m:math>.</para>
      <para id="id63700">Despite this excellent potential performance, there is still a tremendous challenge.
Brute force computation of the globally minimum energy
solution <m:math overflow="scroll"><m:mover accent="true"><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup><m:mo>ˆ</m:mo></m:mover></m:math> involves an exhaustive search over
exponentially many sequences and is thus infeasible.
Therefore, Jalali and Weissman rely on <emphasis effect="italics">Markov chain Monte Carlo</emphasis> (MCMC) <link target-id="bid10"/>,
which is a stochastic relaxation approach to optimization. The crux of the matter is to define
an energy function,</para>
      <equation id="uid5">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>ϵ</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>n</m:mi>
              </m:msup>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:msub>
              <m:mi>H</m:mi>
              <m:mi>k</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>n</m:mi>
              </m:msup>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>-</m:mo>
            <m:mi>β</m:mi>
            <m:mi>d</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>x</m:mi>
                <m:mi>n</m:mi>
              </m:msup>
              <m:mo>,</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>n</m:mi>
              </m:msup>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id63818">The Boltzmann probability mass function (pmf) is</para>
      <equation id="uid6">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>f</m:mi>
              <m:mi>s</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>n</m:mi>
              </m:msup>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>≜</m:mo>
            <m:mfrac>
              <m:mn>1</m:mn>
              <m:msub>
                <m:mi>Z</m:mi>
                <m:mi>t</m:mi>
              </m:msub>
            </m:mfrac>
            <m:mo form="prefix">exp</m:mo>
            <m:mrow>
              <m:mo>{</m:mo>
              <m:mo>-</m:mo>
              <m:mfrac>
                <m:mn>1</m:mn>
                <m:mi>t</m:mi>
              </m:mfrac>
              <m:mi>ε</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msup>
                  <m:mi>w</m:mi>
                  <m:mi>n</m:mi>
                </m:msup>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>}</m:mo>
            </m:mrow>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id63906">where <m:math overflow="scroll"><m:mrow><m:mi>t</m:mi><m:mo>&gt;</m:mo><m:mn>0</m:mn></m:mrow></m:math> is related to temperature in simulated
annealing, and <m:math overflow="scroll"><m:msub><m:mi>Z</m:mi><m:mi>t</m:mi></m:msub></m:math> is the normalization constant,
which does not need to be computed.</para>
      <para id="id63938">Because it is difficult to sample from the Boltzmann pmf <link target-id="uid6"/>
directly, we instead use a <emphasis effect="italics">Gibbs sampler</emphasis>, which computes the marginal distributions
at all <m:math overflow="scroll"><m:mi>n</m:mi></m:math> locations conditioned on the rest of <m:math overflow="scroll"><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup></m:math> being kept fixed.
For each location, the Gibbs sampler resamples from the distribution of
<m:math overflow="scroll"><m:msub><m:mi>w</m:mi><m:mi>i</m:mi></m:msub></m:math> conditioned on <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mrow><m:mi>n</m:mi><m:mo>∖</m:mo><m:mi>i</m:mi></m:mrow></m:msup><m:mo>≜</m:mo><m:mrow><m:mo>{</m:mo><m:msub><m:mi>w</m:mi><m:mi>n</m:mi></m:msub><m:mo>:</m:mo><m:mspace width="4pt"/><m:mi>n</m:mi><m:mo>≠</m:mo><m:mi>i</m:mi><m:mo>}</m:mo></m:mrow></m:mrow></m:math>
as induced by the joint pmf in <link target-id="uid6"/>,
which is computed as follows,</para>
      <equation id="uid7">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mo form="prefix">Pr</m:mo>
                  <m:mo>(</m:mo>
                  <m:msub>
                    <m:mi>w</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>=</m:mo>
                  <m:mi>b</m:mi>
                  <m:mo>|</m:mo>
                  <m:msup>
                    <m:mi>w</m:mi>
                    <m:mrow>
                      <m:mi>n</m:mi>
                      <m:mo>∖</m:mo>
                      <m:mi>i</m:mi>
                    </m:mrow>
                  </m:msup>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mfrac>
                  <m:mrow>
                    <m:mo form="prefix">Pr</m:mo>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>w</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:mo>=</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>,</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mrow>
                        <m:mi>n</m:mi>
                        <m:mo>∖</m:mo>
                        <m:mi>i</m:mi>
                      </m:mrow>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mrow>
                    <m:mo form="prefix">Pr</m:mo>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mrow>
                        <m:mi>n</m:mi>
                        <m:mo>∖</m:mo>
                        <m:mi>i</m:mi>
                      </m:mrow>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mfrac>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mfrac>
                  <m:mrow>
                    <m:mo form="prefix">Pr</m:mo>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>w</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:mo>=</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>,</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mrow>
                        <m:mi>n</m:mi>
                        <m:mo>∖</m:mo>
                        <m:mi>i</m:mi>
                      </m:mrow>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mrow>
                    <m:msub>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:msup>
                          <m:mi>b</m:mi>
                          <m:mo>'</m:mo>
                        </m:msup>
                        <m:mo>∈</m:mo>
                        <m:mover accent="true">
                          <m:mi>α</m:mi>
                          <m:mo>ˆ</m:mo>
                        </m:mover>
                      </m:mrow>
                    </m:msub>
                    <m:mo form="prefix">Pr</m:mo>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msub>
                        <m:mi>w</m:mi>
                        <m:mi>i</m:mi>
                      </m:msub>
                      <m:mo>=</m:mo>
                      <m:msup>
                        <m:mi>b</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                      <m:mo>,</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mrow>
                          <m:mi>n</m:mi>
                          <m:mo>∖</m:mo>
                          <m:mi>i</m:mi>
                        </m:mrow>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:mfrac>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mfrac>
                    <m:mrow>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:msub>
                          <m:mi>Z</m:mi>
                          <m:mi>t</m:mi>
                        </m:msub>
                      </m:mfrac>
                      <m:mo form="prefix">exp</m:mo>
                      <m:mrow>
                        <m:mo>{</m:mo>
                        <m:mo>-</m:mo>
                        <m:mfrac>
                          <m:mn>1</m:mn>
                          <m:mi>t</m:mi>
                        </m:mfrac>
                        <m:mi>ϵ</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msub>
                            <m:mi>w</m:mi>
                            <m:mi>i</m:mi>
                          </m:msub>
                          <m:mo>=</m:mo>
                          <m:mi>b</m:mi>
                          <m:mo>,</m:mo>
                          <m:msup>
                            <m:mi>w</m:mi>
                            <m:mrow>
                              <m:mi>n</m:mi>
                              <m:mo>∖</m:mo>
                              <m:mi>i</m:mi>
                            </m:mrow>
                          </m:msup>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>}</m:mo>
                      </m:mrow>
                    </m:mrow>
                    <m:mrow>
                      <m:msub>
                        <m:mo>∑</m:mo>
                        <m:msup>
                          <m:mi>b</m:mi>
                          <m:mo>'</m:mo>
                        </m:msup>
                      </m:msub>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:msub>
                          <m:mi>Z</m:mi>
                          <m:mi>t</m:mi>
                        </m:msub>
                      </m:mfrac>
                      <m:mo form="prefix">exp</m:mo>
                      <m:mrow>
                        <m:mo>{</m:mo>
                        <m:mo>-</m:mo>
                        <m:mfrac>
                          <m:mn>1</m:mn>
                          <m:mi>t</m:mi>
                        </m:mfrac>
                        <m:mi>ϵ</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msub>
                            <m:mi>w</m:mi>
                            <m:mi>i</m:mi>
                          </m:msub>
                          <m:mo>=</m:mo>
                          <m:msup>
                            <m:mi>b</m:mi>
                            <m:mo>'</m:mo>
                          </m:msup>
                          <m:mo>,</m:mo>
                          <m:msup>
                            <m:mi>w</m:mi>
                            <m:mrow>
                              <m:mi>n</m:mi>
                              <m:mo>∖</m:mo>
                              <m:mi>i</m:mi>
                            </m:mrow>
                          </m:msup>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>}</m:mo>
                      </m:mrow>
                    </m:mrow>
                  </m:mfrac>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id64435">We can now write,</para>
      <equation id="uid8">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>ϵ</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msub>
                <m:mi>y</m:mi>
                <m:mi>i</m:mi>
              </m:msub>
              <m:mo>=</m:mo>
              <m:mi>b</m:mi>
              <m:mo>,</m:mo>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mi>n</m:mi>
                  <m:mo>∖</m:mo>
                  <m:mi>i</m:mi>
                </m:mrow>
              </m:msup>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mi>ϵ</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msub>
                <m:mi>y</m:mi>
                <m:mi>i</m:mi>
              </m:msub>
              <m:mo>=</m:mo>
              <m:mi>a</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>+</m:mo>
            <m:mi>Δ</m:mi>
            <m:mi>H</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>b</m:mi>
              <m:mo>,</m:mo>
              <m:mi>a</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>-</m:mo>
            <m:mi>β</m:mi>
            <m:mi>Δ</m:mi>
            <m:mi>d</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>b</m:mi>
              <m:mo>,</m:mo>
              <m:mi>a</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id64549">where <m:math overflow="scroll"><m:mrow><m:mi>Δ</m:mi><m:msub><m:mi>H</m:mi><m:mi>k</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mi>y</m:mi><m:mrow><m:mi>i</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msup><m:mi>b</m:mi><m:msubsup><m:mi>y</m:mi><m:mrow><m:mi>i</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow><m:mi>n</m:mi></m:msubsup><m:mo>,</m:mo><m:mi>a</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math> is the change in <m:math overflow="scroll"><m:mrow><m:msub><m:mi>H</m:mi><m:mi>k</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow></m:mrow></m:math>
when <m:math overflow="scroll"><m:mrow><m:msub><m:mi>y</m:mi><m:mi>i</m:mi></m:msub><m:mo>=</m:mo><m:mi>a</m:mi></m:mrow></m:math> is replaced by <m:math overflow="scroll"><m:mi>b</m:mi></m:math>, and
<m:math overflow="scroll"><m:mrow><m:mi>Δ</m:mi><m:mi>d</m:mi><m:mrow><m:mo>(</m:mo><m:mi>b</m:mi><m:mo>,</m:mo><m:mi>a</m:mi><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>d</m:mi><m:mrow><m:mo>(</m:mo><m:mi>b</m:mi><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>)</m:mo></m:mrow><m:mo>-</m:mo><m:mi>d</m:mi><m:mrow><m:mo>(</m:mo><m:mi>a</m:mi><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msup><m:mrow><m:mo>(</m:mo><m:mi>b</m:mi><m:mo>-</m:mo><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>)</m:mo></m:mrow><m:mn>2</m:mn></m:msup><m:mo>-</m:mo><m:msup><m:mrow><m:mo>(</m:mo><m:mi>a</m:mi><m:mo>-</m:mo><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>)</m:mo></m:mrow><m:mn>2</m:mn></m:msup></m:mrow></m:math>
is the change in distortion.
Combining <link target-id="uid7"/> and <link target-id="uid8"/>,</para>
      <equation id="uid9">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mo form="prefix">Pr</m:mo>
                  <m:mo>(</m:mo>
                  <m:msub>
                    <m:mi>w</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>=</m:mo>
                  <m:mi>b</m:mi>
                  <m:mo>|</m:mo>
                  <m:msup>
                    <m:mi>w</m:mi>
                    <m:mrow>
                      <m:mi>n</m:mi>
                      <m:mo>∖</m:mo>
                      <m:mi>i</m:mi>
                    </m:mrow>
                  </m:msup>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mfrac>
                  <m:mrow>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mo>{</m:mo>
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:mi>t</m:mi>
                    </m:mfrac>
                    <m:mrow>
                      <m:mo>[</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>a</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>+</m:mo>
                      <m:mi>Δ</m:mi>
                      <m:mi>H</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>b</m:mi>
                        <m:mo>,</m:mo>
                        <m:mi>a</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>-</m:mo>
                      <m:mi>β</m:mi>
                      <m:mi>Δ</m:mi>
                      <m:mi>d</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>b</m:mi>
                        <m:mo>,</m:mo>
                        <m:mi>a</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>]</m:mo>
                    </m:mrow>
                    <m:mo>}</m:mo>
                  </m:mrow>
                  <m:mrow>
                    <m:msub>
                      <m:mo>∑</m:mo>
                      <m:msup>
                        <m:mi>b</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                    </m:msub>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mrow>
                      <m:mo>{</m:mo>
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:mi>t</m:mi>
                      </m:mfrac>
                      <m:mrow>
                        <m:mo>[</m:mo>
                        <m:mi>ϵ</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>a</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>+</m:mo>
                        <m:mi>Δ</m:mi>
                        <m:mi>H</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msup>
                            <m:mi>b</m:mi>
                            <m:mo>'</m:mo>
                          </m:msup>
                          <m:mo>,</m:mo>
                          <m:mi>a</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>-</m:mo>
                        <m:mi>β</m:mi>
                        <m:mi>Δ</m:mi>
                        <m:mi>d</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msup>
                            <m:mi>b</m:mi>
                            <m:mo>'</m:mo>
                          </m:msup>
                          <m:mo>,</m:mo>
                          <m:mi>a</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>]</m:mo>
                      </m:mrow>
                      <m:mo>}</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:mfrac>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mfrac>
                  <m:mrow>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mo>{</m:mo>
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:mi>t</m:mi>
                    </m:mfrac>
                    <m:mo>·</m:mo>
                    <m:mn>0</m:mn>
                    <m:mo>}</m:mo>
                  </m:mrow>
                  <m:mrow>
                    <m:msub>
                      <m:mo>∑</m:mo>
                      <m:msup>
                        <m:mi>b</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                    </m:msub>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mrow>
                      <m:mo>{</m:mo>
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:mi>t</m:mi>
                      </m:mfrac>
                      <m:mrow>
                        <m:mo>[</m:mo>
                        <m:mi>Δ</m:mi>
                        <m:mi>H</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msup>
                            <m:mi>b</m:mi>
                            <m:mo>'</m:mo>
                          </m:msup>
                          <m:mo>,</m:mo>
                          <m:mi>a</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>-</m:mo>
                        <m:mi>β</m:mi>
                        <m:mi>Δ</m:mi>
                        <m:mi>d</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msup>
                            <m:mi>b</m:mi>
                            <m:mo>'</m:mo>
                          </m:msup>
                          <m:mo>,</m:mo>
                          <m:mi>a</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>-</m:mo>
                        <m:mi>Δ</m:mi>
                        <m:mi>H</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>b</m:mi>
                          <m:mo>,</m:mo>
                          <m:mi>a</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>+</m:mo>
                        <m:mi>β</m:mi>
                        <m:mi>Δ</m:mi>
                        <m:mi>d</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>b</m:mi>
                          <m:mo>,</m:mo>
                          <m:mi>a</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>]</m:mo>
                      </m:mrow>
                      <m:mo>}</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:mfrac>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mfrac>
                  <m:mn>1</m:mn>
                  <m:mrow>
                    <m:msub>
                      <m:mo>∑</m:mo>
                      <m:msup>
                        <m:mi>b</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                    </m:msub>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mrow>
                      <m:mo>{</m:mo>
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:mi>t</m:mi>
                      </m:mfrac>
                      <m:mrow>
                        <m:mo>[</m:mo>
                        <m:mi>Δ</m:mi>
                        <m:mi>H</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msup>
                            <m:mi>b</m:mi>
                            <m:mo>'</m:mo>
                          </m:msup>
                          <m:mo>,</m:mo>
                          <m:mi>b</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>-</m:mo>
                        <m:mi>β</m:mi>
                        <m:mi>Δ</m:mi>
                        <m:mi>d</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msup>
                            <m:mi>b</m:mi>
                            <m:mo>'</m:mo>
                          </m:msup>
                          <m:mo>,</m:mo>
                          <m:mi>b</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>]</m:mo>
                      </m:mrow>
                      <m:mo>}</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:mfrac>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id65298">The maximum change in the energy within an iteration of MCMC algorithm is then bounded by</para>
      <equation id="uid10">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msub>
                    <m:mi>Δ</m:mi>
                    <m:mi>k</m:mi>
                  </m:msub>
                  <m:mo>=</m:mo>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">max</m:mo>
                    <m:mrow>
                      <m:mn>1</m:mn>
                      <m:mo>≤</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>≤</m:mo>
                      <m:mi>n</m:mi>
                    </m:mrow>
                  </m:munder>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">max</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>∈</m:mo>
                      <m:msup>
                        <m:mover accent="true">
                          <m:mi>α</m:mi>
                          <m:mo>ˆ</m:mo>
                        </m:mover>
                        <m:mi>n</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:munder>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">max</m:mo>
                    <m:mrow>
                      <m:mi>b</m:mi>
                      <m:mo>,</m:mo>
                      <m:msup>
                        <m:mi>b</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                      <m:mo>∈</m:mo>
                      <m:mover accent="true">
                        <m:mi>α</m:mi>
                        <m:mo>ˆ</m:mo>
                      </m:mover>
                    </m:mrow>
                  </m:munder>
                  <m:mrow>
                    <m:mo>|</m:mo>
                    <m:mi>n</m:mi>
                    <m:mi>Δ</m:mi>
                    <m:msub>
                      <m:mi>H</m:mi>
                      <m:mi>k</m:mi>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>b</m:mi>
                      <m:mo>,</m:mo>
                      <m:msup>
                        <m:mi>b</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>+</m:mo>
                    <m:msub>
                      <m:mi>c</m:mi>
                      <m:mn>4</m:mn>
                    </m:msub>
                    <m:mi>Δ</m:mi>
                    <m:mi>d</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>b</m:mi>
                      <m:mo>,</m:mo>
                      <m:msup>
                        <m:mi>b</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>|</m:mo>
                  </m:mrow>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id65497">We refer to the resampling from a single location as an iteration,
and group the <m:math overflow="scroll"><m:mi>n</m:mi></m:math> possible locations into super-iterations.<footnote id="uid11">Baron and Weissman <link target-id="bid11"/>
recommend an ordering where each super-iteration scans
a permutation of all <m:math overflow="scroll"><m:mi>n</m:mi></m:math> locations of the input, because in this manner
each location is scanned fairly often. Other orderings
are possible, including a completely random order.</footnote></para>
      <para id="id65536">During the simulated annealing, the temperature <m:math overflow="scroll"><m:mi>t</m:mi></m:math>
is gradually increased, where in
super-iteration <m:math overflow="scroll"><m:mi>i</m:mi></m:math> we use <m:math overflow="scroll"><m:mrow><m:mi>t</m:mi><m:mo>=</m:mo><m:mi>O</m:mi><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>/</m:mo><m:mo form="prefix">log</m:mo><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo><m:mo>)</m:mo></m:mrow></m:math> <link target-id="bid10"/>, <link target-id="bid8"/>.
In each iteration, the Gibbs sampler modifies <m:math overflow="scroll"><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup></m:math> in a
random manner that resembles heat bath concepts in statistical physics. Although
MCMC could sink into a local minimum, we decrease the temperature slowly enough
that the randomness of Gibbs sampling eventually drives MCMC out of the local
minimum toward the set of minimal energy solutions, which includes <m:math overflow="scroll"><m:mover accent="true"><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup><m:mo>ˆ</m:mo></m:mover></m:math>,
because low temperature <m:math overflow="scroll"><m:mi>t</m:mi></m:math> favors low-energy <m:math overflow="scroll"><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup></m:math>.
Pseudo-code for our encoder appears in Algorithm 1 below.</para>
      <para id="id62519"><emphasis effect="smallcaps"><emphasis effect="underline">Algorithm 1</emphasis>: Lossy encoder with fixed reproduction alphabet</emphasis><emphasis effect="smallcaps">Input:</emphasis><m:math overflow="scroll"><m:mrow><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:msup><m:mi>α</m:mi><m:mi>n</m:mi></m:msup></m:mrow></m:math>, <m:math overflow="scroll"><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover></m:math>, <m:math overflow="scroll"><m:mi>β</m:mi></m:math>, <m:math overflow="scroll"><m:mi>c</m:mi></m:math>, <m:math overflow="scroll"><m:mi>r</m:mi></m:math><emphasis effect="smallcaps">Output:</emphasis> bit-stream <emphasis effect="smallcaps">Procedure:</emphasis><list id="id65854" display="block" list-type="enumerated"><item id="uid12">Initialize <m:math overflow="scroll"><m:mi>w</m:mi></m:math> by quantizing <m:math overflow="scroll"><m:mi>x</m:mi></m:math> with <m:math overflow="scroll"><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover></m:math></item>

<item id="uid13">Initialize <m:math overflow="scroll"><m:mrow><m:msub><m:mi>n</m:mi><m:mi>w</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>,</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:mrow></m:math> using <m:math overflow="scroll"><m:mi>w</m:mi></m:math></item>

<item id="uid14"><emphasis effect="bold">for</emphasis> <m:math overflow="scroll"><m:mrow><m:mi>r</m:mi><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math> to <m:math overflow="scroll"><m:mi>R</m:mi></m:math> <emphasis effect="bold">do</emphasis> // <emphasis effect="italics">super-iteration</emphasis></item>

<item id="uid15">     <m:math overflow="scroll"><m:mrow><m:msub><m:mi>t</m:mi><m:mi>r</m:mi></m:msub><m:mo>←</m:mo><m:mfrac><m:mrow><m:mi>c</m:mi><m:mi>n</m:mi><m:msub><m:mi>Δ</m:mi><m:mi>k</m:mi></m:msub></m:mrow><m:mrow><m:mo form="prefix">log</m:mo><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:mfrac></m:mrow></m:math>
// <emphasis effect="italics">temperature</emphasis></item>

<item id="uid16">     Draw permutation of numbers <m:math overflow="scroll"><m:mrow><m:mo>{</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:mi>n</m:mi><m:mo>}</m:mo></m:mrow></m:math> at random

</item><item id="uid17">     <emphasis effect="bold">for</emphasis> <m:math overflow="scroll"><m:mrow><m:msup><m:mi>r</m:mi><m:mo>'</m:mo></m:msup><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math> to <m:math overflow="scroll"><m:mi>n</m:mi></m:math> <emphasis effect="bold">do</emphasis> </item><item id="uid18">        Let <m:math overflow="scroll"><m:mi>j</m:mi></m:math> be component <m:math overflow="scroll"><m:msup><m:mi>t</m:mi><m:mo>'</m:mo></m:msup></m:math> in permutation

</item><item id="uid19">        Generate new <m:math overflow="scroll"><m:msub><m:mi>w</m:mi><m:mi>j</m:mi></m:msub></m:math> using <m:math overflow="scroll"><m:mrow><m:msub><m:mi>f</m:mi><m:mi>s</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:msub><m:mi>w</m:mi><m:mi>j</m:mi></m:msub><m:mo>=</m:mo><m:mo>·</m:mo><m:mo>|</m:mo><m:msup><m:mi>w</m:mi><m:mrow><m:mi>n</m:mi><m:mo>∖</m:mo><m:mi>j</m:mi></m:mrow></m:msup><m:mo>)</m:mo></m:mrow></m:mrow></m:math>

</item><item id="uid20">        Update <m:math overflow="scroll"><m:mrow><m:msub><m:mi>n</m:mi><m:mi>w</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>,</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow><m:mrow><m:mo>[</m:mo><m:mo>·</m:mo><m:mo>]</m:mo></m:mrow></m:mrow></m:math></item><item id="uid21">Apply CTW to <m:math overflow="scroll"><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup></m:math> // <emphasis effect="italics">compress outcome</emphasis></item></list></para>
    </section>
    <section id="uid22">
      <title>Computational issues</title>
      <para id="id66394">Looking at the pseudo-code, it is clear that the following could be computational bottlenecks:</para>
      <list id="id66398" display="block" list-type="enumerated">
        <item id="uid23">Initializing <m:math overflow="scroll"><m:mrow><m:msub><m:mi>n</m:mi><m:mi>w</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>,</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:mrow></m:math> - a naive implementation needs to scan the sequence <m:math overflow="scroll"><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup></m:math> (complexity <m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:mi>n</m:mi><m:mo>)</m:mo></m:mrow></m:math>) and initialize a data structure with <m:math overflow="scroll"><m:mrow><m:mrow><m:mo>|</m:mo></m:mrow><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:msup><m:mrow><m:mo>|</m:mo></m:mrow><m:mrow><m:mi>K</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:msup></m:mrow></m:math> elements. Unless <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>≲</m:mo><m:msub><m:mo form="prefix">log</m:mo><m:mrow><m:mrow><m:mo>|</m:mo></m:mrow><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mrow><m:mo>|</m:mo></m:mrow></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>n</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>, this is super linear in <m:math overflow="scroll"><m:mi>n</m:mi></m:math>. Therefore, we recall that <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>=</m:mo><m:mi>o</m:mi><m:mo>(</m:mo><m:mo form="prefix">log</m:mo><m:mo>(</m:mo><m:mi>n</m:mi><m:mo>)</m:mo><m:mo>)</m:mo></m:mrow></m:math>, and initializing <m:math overflow="scroll"><m:mrow><m:msub><m:mi>n</m:mi><m:mi>w</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>,</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:mrow></m:math> requires linear complexity <m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:mi>n</m:mi><m:mo>)</m:mo></m:mrow></m:math>.
</item>
        <item id="uid24">The inner loop is run <m:math overflow="scroll"><m:mrow><m:mi>r</m:mi><m:mi>n</m:mi></m:mrow></m:math> times, and each time computing <m:math overflow="scroll"><m:mrow><m:mo form="prefix">Pr</m:mo><m:mo>(</m:mo><m:msub><m:mi>w</m:mi><m:mi>j</m:mi></m:msub><m:mo>=</m:mo><m:mi>b</m:mi><m:mo>|</m:mo><m:msup><m:mi>w</m:mi><m:mrow><m:mi>n</m:mi><m:mo>∖</m:mo><m:mi>j</m:mi></m:mrow></m:msup><m:mo>)</m:mo></m:mrow></m:math> for all possible <m:math overflow="scroll"><m:mrow><m:mi>b</m:mi><m:mo>∈</m:mo><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover></m:mrow></m:math> might be challenging. In particular, let us consider computation of <m:math overflow="scroll"><m:mrow><m:mi>Δ</m:mi><m:mi>d</m:mi></m:mrow></m:math> and <m:math overflow="scroll"><m:mrow><m:mi>Δ</m:mi><m:mi>H</m:mi></m:mrow></m:math>.
<list id="id66747" display="block" list-type="enumerated"><item id="uid25">Computation of <m:math overflow="scroll"><m:mrow><m:mi>Δ</m:mi><m:mi>d</m:mi></m:mrow></m:math> requires constant time, and is not burdensome.
</item>

<item id="uid26">Computation of <m:math overflow="scroll"><m:mrow><m:mi>Δ</m:mi><m:mi>H</m:mi></m:mrow></m:math> requires to modify the symbol counts for each context that was modified.
A key contribution by Jalali and Weissman 
was to recognize that the array of symbol counts, <m:math overflow="scroll"><m:mrow><m:msub><m:mi>n</m:mi><m:mi>w</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>,</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:mrow></m:math>,
would change in <m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:mi>k</m:mi><m:mo>)</m:mo></m:mrow></m:math> locations, where <m:math overflow="scroll"><m:mi>k</m:mi></m:math> is the context order. Therefore, each computation of <m:math overflow="scroll"><m:mrow><m:mi>Δ</m:mi><m:mi>H</m:mi></m:mrow></m:math>
requires <m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:mi>k</m:mi><m:mo>)</m:mo></m:mrow></m:math> time. Seeing that <m:math overflow="scroll"><m:mrow><m:mrow><m:mo>|</m:mo></m:mrow><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mrow><m:mo>|</m:mo></m:mrow></m:mrow></m:math> such computations per iteration are needed,
and there are <m:math overflow="scroll"><m:mrow><m:mi>r</m:mi><m:mi>n</m:mi></m:mrow></m:math> iterations, this is <m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:mi>k</m:mi><m:mi>r</m:mi><m:mi>n</m:mi><m:mo>|</m:mo><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mo>|</m:mo><m:mo>)</m:mo></m:mrow></m:math>.
</item><item id="uid27">Updating <m:math overflow="scroll"><m:mrow><m:msub><m:mi>n</m:mi><m:mi>w</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>,</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:mrow></m:math> after <m:math overflow="scroll"><m:msub><m:mi>w</m:mi><m:mi>j</m:mi></m:msub></m:math> is re-sampled from the Boltzmann distribution also requires
<m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:mi>k</m:mi><m:mo>)</m:mo></m:mrow></m:math> time. However, this step is performed only once per iteration, and not <m:math overflow="scroll"><m:mrow><m:mrow><m:mo>|</m:mo></m:mrow><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mrow><m:mo>|</m:mo></m:mrow></m:mrow></m:math> times.
Therefore, this step requires less computation than step (b).
</item></list></item>
      </list>
    </section>
    <section id="uid28">
      <title>Lossy compression of an analog input</title>
      <para id="id67064">So far, we have described the approach by Jalali and Weissman to compress <m:math overflow="scroll"><m:mrow><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:msup><m:mi>α</m:mi><m:mi>n</m:mi></m:msup></m:mrow></m:math>. Suppose instead that <m:math overflow="scroll"><m:mrow><m:mi>x</m:mi><m:mo>∈</m:mo><m:msup><m:mi mathvariant="double-struck">R</m:mi><m:mi>n</m:mi></m:msup></m:mrow></m:math> is analog. Seeing that MCMC optimizes <m:math overflow="scroll"><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup></m:math> over a discrete alphabet, it would be convenient to keep doing so. However, because <m:math overflow="scroll"><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> is finite, and assuming that square distortion is used, i.i., <m:math overflow="scroll"><m:mrow><m:mi>d</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>,</m:mo><m:msub><m:mi>w</m:mi><m:mi>i</m:mi></m:msub><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msup><m:mrow><m:mo>(</m:mo><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>-</m:mo><m:msub><m:mi>w</m:mi><m:mi>i</m:mi></m:msub><m:mo>)</m:mo></m:mrow><m:mn>2</m:mn></m:msup></m:mrow></m:math>, we see that the distortion could be large.</para>
      <para id="id67209">Fortunately, Baron and Weissman showed <link target-id="bid11"/>
that the following quantizer has favorable properties,</para>
      <equation id="uid29">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mover accent="true">
              <m:mi>α</m:mi>
              <m:mo>ˆ</m:mo>
            </m:mover>
            <m:mo>=</m:mo>
            <m:mrow>
              <m:mo>{</m:mo>
              <m:mfrac>
                <m:mrow>
                  <m:mo>-</m:mo>
                  <m:msup>
                    <m:mi>γ</m:mi>
                    <m:mn>2</m:mn>
                  </m:msup>
                </m:mrow>
                <m:mi>γ</m:mi>
              </m:mfrac>
              <m:mo>,</m:mo>
              <m:mfrac>
                <m:mrow>
                  <m:mo>-</m:mo>
                  <m:msup>
                    <m:mi>γ</m:mi>
                    <m:mn>2</m:mn>
                  </m:msup>
                  <m:mo>+</m:mo>
                  <m:mn>1</m:mn>
                </m:mrow>
                <m:mi>γ</m:mi>
              </m:mfrac>
              <m:mo>,</m:mo>
              <m:mo>⋯</m:mo>
              <m:mo>,</m:mo>
              <m:mn>0</m:mn>
              <m:mo>,</m:mo>
              <m:mfrac>
                <m:mn>1</m:mn>
                <m:mi>γ</m:mi>
              </m:mfrac>
              <m:mo>,</m:mo>
              <m:mo>⋯</m:mo>
              <m:mo>,</m:mo>
              <m:mfrac>
                <m:mrow>
                  <m:mo>+</m:mo>
                  <m:msup>
                    <m:mi>γ</m:mi>
                    <m:mn>2</m:mn>
                  </m:msup>
                </m:mrow>
                <m:mi>γ</m:mi>
              </m:mfrac>
              <m:mo>}</m:mo>
            </m:mrow>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id67329">where <m:math overflow="scroll"><m:mi>γ</m:mi></m:math> is an integer that grows with <m:math overflow="scroll"><m:mi>n</m:mi></m:math>. That is, as <m:math overflow="scroll"><m:mi>γ</m:mi></m:math> grows the set <m:math overflow="scroll"><m:mover accent="true"><m:mi>α</m:mi><m:mo>^</m:mo></m:mover></m:math>
of reproduction levels quantizers a wider internal more finely. Therefore, we have that the probability that
some <m:math overflow="scroll"><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub></m:math> is an outlier, i.e., <m:math overflow="scroll"><m:mrow><m:mrow><m:mo>|</m:mo></m:mrow><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mrow><m:mo>|</m:mo><m:mo>&lt;</m:mo><m:mi>γ</m:mi></m:mrow></m:mrow></m:math>, vanishes with <m:math overflow="scroll"><m:mi>n</m:mi></m:math>, and the effect of outliers on
<m:math overflow="scroll"><m:mrow><m:mover><m:mi>d</m:mi><m:mo>¯</m:mo></m:mover><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mover><m:mi>x</m:mi><m:mo>¯</m:mo></m:mover><m:mo>)</m:mo></m:mrow></m:mrow></m:math> vanishes. Moreover, because the internal is sampled more finely as
<m:math overflow="scroll"><m:mi>γ</m:mi></m:math> increases with <m:math overflow="scroll"><m:mi>n</m:mi></m:math>, this quantizer can emulate any codebook with continuous levels,
and so in the limit its RD performance converges to the RD function.</para>
    </section>
    <section id="uid30">
      <title>Rate distortion performance</title>
      <para id="id67489">To evaluate the RD performance, we must first define the RD function.
Consider a source <m:math overflow="scroll"><m:mi>X</m:mi></m:math> that generates a sequence <m:math overflow="scroll"><m:mrow><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:msup><m:mi mathvariant="double-struck">R</m:mi><m:mi>n</m:mi></m:msup></m:mrow></m:math>.
A <emphasis effect="italics">lossy encoder</emphasis> is a mapping <m:math overflow="scroll"><m:mrow><m:mi>e</m:mi><m:mo>:</m:mo><m:msup><m:mi mathvariant="double-struck">R</m:mi><m:mi>n</m:mi></m:msup><m:mo>→</m:mo><m:mi mathvariant="script">C</m:mi></m:mrow></m:math>,
where <m:math overflow="scroll"><m:mrow><m:mi mathvariant="script">C</m:mi><m:mo>⊂</m:mo><m:msup><m:mi mathvariant="double-struck">R</m:mi><m:mi>n</m:mi></m:msup></m:mrow></m:math> is a codebook that contains a set of
codewords in <m:math overflow="scroll"><m:msup><m:mi mathvariant="double-struck">R</m:mi><m:mi>n</m:mi></m:msup></m:math>.
Let <m:math overflow="scroll"><m:mrow><m:msup><m:mi mathvariant="script">C</m:mi><m:mi>n</m:mi></m:msup><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>D</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math> be the smallest cardinality codebook for inputs
of length <m:math overflow="scroll"><m:mi>n</m:mi></m:math> generated by <m:math overflow="scroll"><m:mi>X</m:mi></m:math> such that the expected per-symbol distortion
between the input <m:math overflow="scroll"><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup></m:math> and the codeword <m:math overflow="scroll"><m:mrow><m:mi>e</m:mi><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>∈</m:mo><m:msup><m:mi mathvariant="script">C</m:mi><m:mi>n</m:mi></m:msup><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>D</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>
is at most <m:math overflow="scroll"><m:mi>D</m:mi></m:math>. The rate <m:math overflow="scroll"><m:mrow><m:msup><m:mi>R</m:mi><m:mi>n</m:mi></m:msup><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>D</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math> is the per-symbol log-cardinality of the codebook,</para>
      <equation id="id67744">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msup>
              <m:mi>R</m:mi>
              <m:mi>n</m:mi>
            </m:msup>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>x</m:mi>
              <m:mo>,</m:mo>
              <m:mi>D</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mfrac>
              <m:mn>1</m:mn>
              <m:mi>n</m:mi>
            </m:mfrac>
            <m:mrow>
              <m:mo form="prefix">log</m:mo>
              <m:mo>(</m:mo>
              <m:mo>|</m:mo>
            </m:mrow>
            <m:msup>
              <m:mi mathvariant="script">C</m:mi>
              <m:mi>n</m:mi>
            </m:msup>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>x</m:mi>
              <m:mo>,</m:mo>
              <m:mi>D</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mrow>
              <m:mo>|</m:mo>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id67819">This is an operational definition of the RD function in terms
of the best block code. In contrast, it can be shown that the RD function is equal
to a minimization over mutual information, yielding a different flavor of
definition <link target-id="bid1"/>, <link target-id="bid0"/>.</para>
      <para id="id67840">Having defined the RD function, we can describe the RD performance of the
compression algorithm by Baron and Weissman for continuous valued inputs.</para>
      <para id="id67844"><emphasis effect="bold">Theorem 8</emphasis> Consider square error distortion, <m:math overflow="scroll"><m:mrow><m:mi>d</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>,</m:mo><m:msub><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>i</m:mi></m:msub><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msup><m:mrow><m:mo>(</m:mo><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>-</m:mo><m:msub><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>i</m:mi></m:msub><m:mo>)</m:mo></m:mrow><m:mn>2</m:mn></m:msup></m:mrow></m:math>,
let <m:math overflow="scroll"><m:mi>X</m:mi></m:math> be a finite variance stationary and ergodic source with RD function <m:math overflow="scroll"><m:mrow><m:mi>R</m:mi><m:mo>(</m:mo><m:mi>X</m:mi><m:mo>,</m:mo><m:mi>D</m:mi><m:mo>)</m:mo></m:mrow></m:math>,
and use the MCMC algorithm with data independent reproduction alphabet <m:math overflow="scroll"><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover></m:math>
and temperature that decays sufficiently slowly. Let <m:math overflow="scroll"><m:msubsup><m:mi>w</m:mi><m:mi>r</m:mi><m:mi>n</m:mi></m:msubsup></m:math> be the approximation to <m:math overflow="scroll"><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup></m:math>
after <m:math overflow="scroll"><m:mi>r</m:mi></m:math> super-iterations. Then the length of context tree weighting (CTW) applied to
<m:math overflow="scroll"><m:msubsup><m:mi>w</m:mi><m:mi>r</m:mi><m:mi>n</m:mi></m:msubsup></m:math> converges as follows,</para><equation id="id68038">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">lim</m:mo>
              <m:mrow>
                <m:mi>n</m:mi>
                <m:mo>→</m:mo>
                <m:mi>∞</m:mi>
              </m:mrow>
            </m:munder>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">lim</m:mo>
              <m:mrow>
                <m:mi>r</m:mi>
                <m:mo>→</m:mo>
                <m:mi>∞</m:mi>
              </m:mrow>
            </m:munder>
            <m:mi>E</m:mi>
            <m:mfenced separators="" open="[" close="]">
              <m:mfrac>
                <m:mn>1</m:mn>
                <m:mi>n</m:mi>
              </m:mfrac>
              <m:mrow>
                <m:mo>|</m:mo>
                <m:mi>C</m:mi>
                <m:mi>T</m:mi>
                <m:mi>W</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:msubsup>
                    <m:mi>W</m:mi>
                    <m:mi>r</m:mi>
                    <m:mi>n</m:mi>
                  </m:msubsup>
                  <m:mo>)</m:mo>
                </m:mrow>
                <m:mo>|</m:mo>
              </m:mrow>
              <m:mo>-</m:mo>
              <m:mi>β</m:mi>
              <m:mover accent="true">
                <m:mi>d</m:mi>
                <m:mo>¯</m:mo>
              </m:mover>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msup>
                  <m:mi>x</m:mi>
                  <m:mi>n</m:mi>
                </m:msup>
                <m:mo>,</m:mo>
                <m:msubsup>
                  <m:mi>W</m:mi>
                  <m:mi>r</m:mi>
                  <m:mi>n</m:mi>
                </m:msubsup>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:mfenced>
            <m:munder accentunder="true">
              <m:mrow>
                <m:mi>n</m:mi>
                <m:mo>→</m:mo>
                <m:mi>∞</m:mi>
              </m:mrow>
              <m:mo>→</m:mo>
            </m:munder>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">min</m:mo>
              <m:mrow>
                <m:mi>D</m:mi>
                <m:mo>≥</m:mo>
                <m:mn>0</m:mn>
              </m:mrow>
            </m:munder>
            <m:mrow>
              <m:mo>[</m:mo>
              <m:mi>R</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>X</m:mi>
                <m:mo>,</m:mo>
                <m:mi>D</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>-</m:mo>
              <m:mi>β</m:mi>
              <m:mi>D</m:mi>
              <m:mo>]</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id68227"><emphasis effect="bold">Remark 1</emphasis> Let us make some comments.</para>
      <list id="id68239" display="block" list-type="bulleted">
        <item id="uid33">This result implies that CTW is used to compress <m:math overflow="scroll"><m:msubsup><m:mi>w</m:mi><m:mi>r</m:mi><m:mi>n</m:mi></m:msubsup></m:math> after it has been generated by MCMC.
Instead of CTW, other universal compression approaches can be used.
</item>
        <item id="uid34">The same result can be proved for <m:math overflow="scroll"><m:msub><m:mi>l</m:mi><m:mi>p</m:mi></m:msub></m:math> distortion metrics, and not just <m:math overflow="scroll"><m:msub><m:mi>l</m:mi><m:mn>2</m:mn></m:msub></m:math>.
</item>
        <item id="uid35">A result with similar flavor was proved by Jalali and Weissman for discrete alphabets <link target-id="bid8"/>.
</item>
      </list>
      <para id="id68334"><emphasis effect="bold">Adaptive reproduction levels</emphasis>: The above algorithm is promising from a theoretical perspective, but is of limited practical interest.
In order to approach the RD function closely, <m:math overflow="scroll"><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> may need to be large, which slows down the algorithm.</para>
      <para id="id68359">Our approach to overcome the large alphabet is inspired by the work by Rose <link target-id="bid13"/>,
who showed that in many cases the optimal RD codebook uses a small discrete-valued
reproduction alphabet. This runs counter to our intuition that a continuous reproduction
alphabet is needed to compress a continuous valued source. Therefore, we propose an
algorithm that allows for reduction of the alphabet size while supporting adaptive
reproduction levels.</para>
      <para id="id68372">We map the input <m:math overflow="scroll"><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup></m:math> to a sequence <m:math overflow="scroll"><m:msup><m:mi>z</m:mi><m:mi>n</m:mi></m:msup></m:math> over a finite alphabet, where actual
numerical values are obtained by a scalar function, <m:math overflow="scroll"><m:mrow><m:mi>g</m:mi><m:mo>(</m:mo><m:msub><m:mi>z</m:mi><m:mi>i</m:mi></m:msub><m:mo>)</m:mo></m:mrow></m:math>. Ideally, <m:math overflow="scroll"><m:mrow><m:mi>g</m:mi><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:math> should
minimize distortion. Because we focus on square error distortion, the optimal
<m:math overflow="scroll"><m:mrow><m:msup><m:mi>g</m:mi><m:mo>∗</m:mo></m:msup><m:mrow><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:mrow></m:math> is conditional expectation,</para><equation id="id68468"><m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msup>
              <m:mi>g</m:mi>
              <m:mo>∗</m:mo>
            </m:msup>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>α</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mi>E</m:mi>
            <m:mrow>
              <m:mo>[</m:mo>
              <m:msub>
                <m:mi>x</m:mi>
                <m:mi>i</m:mi>
              </m:msub>
              <m:mo>|</m:mo>
              <m:msub>
                <m:mi>z</m:mi>
                <m:mi>i</m:mi>
              </m:msub>
              <m:mo>=</m:mo>
              <m:mi>α</m:mi>
              <m:mo>]</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mfrac>
              <m:mrow>
                <m:msub>
                  <m:mo>∑</m:mo>
                  <m:mrow>
                    <m:mi>i</m:mi>
                    <m:mo>:</m:mo>
                    <m:msub>
                      <m:mi>z</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:mo>=</m:mo>
                    <m:mi>a</m:mi>
                  </m:mrow>
                </m:msub>
                <m:msub>
                  <m:mi>x</m:mi>
                  <m:mi>i</m:mi>
                </m:msub>
              </m:mrow>
              <m:mrow>
                <m:msub>
                  <m:mo>∑</m:mo>
                  <m:mrow>
                    <m:mi>i</m:mi>
                    <m:mo>:</m:mo>
                    <m:msub>
                      <m:mi>z</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:mo>=</m:mo>
                    <m:msub>
                      <m:mi>a</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                  </m:mrow>
                </m:msub>
                <m:mn>1</m:mn>
              </m:mrow>
            </m:mfrac>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation><para id="id68592">Keep in mind that in an actual compression system, the encoder knows <m:math overflow="scroll"><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup></m:math>,
but the decoder does not. Therefore, the encoder must describe (a quantized
version of) <m:math overflow="scroll"><m:mrow><m:msup><m:mi>g</m:mi><m:mo>∗</m:mo></m:msup><m:mrow><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:mrow></m:math> to the decoder. Putting aside these details, the
main point is that the adaptive reproduction alphabet algorithm also acheives the
RD function for stationary and ergodic sources while allowing a reduction in the size
of the alphabet, thus accelerating the algorithm.</para></section>
    <section id="uid36">
      <title>Universal signal reconstruction</title>
      <para id="id68646"><emphasis effect="bold">Scalar channel:</emphasis> Consider a scalar channel, <m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>=</m:mo><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>z</m:mi></m:mrow></m:math>, where <m:math overflow="scroll"><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>y</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>∈</m:mo><m:msup><m:mi mathvariant="double-struck">R</m:mi><m:mi>n</m:mi></m:msup></m:mrow></m:math>,
<m:math overflow="scroll"><m:mi>x</m:mi></m:math> is generated by a stationalry and ergodic source <m:math overflow="scroll"><m:mi>X</m:mi></m:math>,
and <m:math overflow="scroll"><m:mrow><m:msub><m:mi>z</m:mi><m:mi>i</m:mi></m:msub><m:mo>∼</m:mo><m:mi>N</m:mi><m:mrow><m:mo>(</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:mn>1</m:mn><m:mo>)</m:mo></m:mrow></m:mrow></m:math> is zero mean unit norm Gaussian noise.
To avoid taking the analysis toward continuous valued <m:math overflow="scroll"><m:mi>x</m:mi></m:math>,
we can simplify the setting and temporarily consider discrete-valued <m:math overflow="scroll"><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>y</m:mi><m:mo>,</m:mo></m:mrow></m:math> and <m:math overflow="scroll"><m:mi>z</m:mi></m:math>;
for example, we can consider a quantized version of the continuous problem.</para>
      <para id="id68789">Donoho <link target-id="bid14"/> proposed the following reconstruction,</para>
      <equation id="uid37">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mover accent="true">
              <m:mi>x</m:mi>
              <m:mo>ˆ</m:mo>
            </m:mover>
            <m:mo>=</m:mo>
            <m:munder>
              <m:mrow>
                <m:mo form="prefix">arg</m:mo>
                <m:mo movablelimits="true" form="prefix">min</m:mo>
              </m:mrow>
              <m:mrow>
                <m:msubsup>
                  <m:mrow>
                    <m:mi>w</m:mi>
                    <m:mi>s</m:mi>
                    <m:mo>.</m:mo>
                    <m:mi>t</m:mi>
                    <m:mo>.</m:mo>
                    <m:mo>∥</m:mo>
                    <m:mi>Y</m:mi>
                    <m:mo>-</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>∥</m:mo>
                  </m:mrow>
                  <m:mn>2</m:mn>
                  <m:mn>2</m:mn>
                </m:msubsup>
                <m:mo>≤</m:mo>
                <m:mi>n</m:mi>
              </m:mrow>
            </m:munder>
            <m:mi>K</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id68887">where <m:math overflow="scroll"><m:mi>w</m:mi></m:math> is a possible reconstruction sequence,
and <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow></m:math> is the Kolmogorov complexity of <m:math overflow="scroll"><m:mi>w</m:mi></m:math>.
Donoho calls this reconstruction algorithm the <emphasis effect="italics">Kolmogorov sampler</emphasis>.</para>
      <para id="id68934">What is the Kolmogorov complexity <link target-id="bid15"/>, <link target-id="bid16"/>, <link target-id="bid17"/>
of the sequence <m:math overflow="scroll"><m:mi>w</m:mi></m:math>?
It is the length of the shortest computer program that outputs <m:math overflow="scroll"><m:mi>w</m:mi></m:math>
and then halts.
One may ask what computer language we can use for the program;
after all, it is easy to imagine some programming language being well-tuned
to a specific sequence <m:math overflow="scroll"><m:mi>w</m:mi></m:math>. However, concepts such as universal Turing machines <link target-id="bid18"/>
can be used to put forward an abstract programming language that will run on any
hypothetical computer. The key point is that the computer is limited to a state machine
that processes an infinite-length tape, and one state machine can emulate another by
programming a compiler onto the tape.</para>
      <para id="id68991">Is it practical to talk about the shortest program that outputs <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and then halts?
Not really, because we would need to run the Turing machine <link target-id="bid18"/> (the computer)
on an exponential number of programs. Moreover, it is well known that for some programs the Turing
machine never halts (there are endless loops), and technical conditions such as time-out mechanisms
will need to be added in. Therefore, computing the Kolmogorov complexity <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow></m:math> is
impractical <link target-id="bid15"/>, <link target-id="bid16"/>, <link target-id="bid17"/>.
However, for <m:math overflow="scroll"><m:mi>w</m:mi></m:math> that was generated by a stationary ergodic source, it is possible to approximate
<m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow></m:math> by <m:math overflow="scroll"><m:mrow><m:msub><m:mi>H</m:mi><m:mi>k</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>, the empirical entropy <link target-id="bid1"/>, <link target-id="bid19"/>.</para>
      <para id="id69105">What is the performance of Donoho's Kolmogorov sampler?
Donoho proved that <m:math overflow="scroll"><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> has the following distribution,
<m:math overflow="scroll"><m:mrow><m:mover accent="true"><m:mi>X</m:mi><m:mo>ˆ</m:mo></m:mover><m:mo>∼</m:mo><m:mi>p</m:mi><m:mrow><m:mo>(</m:mo><m:mi>X</m:mi><m:mo>|</m:mo><m:mi>Y</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math> <link target-id="bid14"/>.
That is, <m:math overflow="scroll"><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> is sampled from the posterior.
Therefore, given <m:math overflow="scroll"><m:mi>y</m:mi></m:math>, we have that <m:math overflow="scroll"><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> and <m:math overflow="scroll"><m:mi>x</m:mi></m:math> are both generated
by the same distribution.</para>
      <para id="id69214">Consider now that <m:math overflow="scroll"><m:msub><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:mrow><m:mi>M</m:mi><m:mi>M</m:mi><m:mi>S</m:mi><m:mi>E</m:mi></m:mrow></m:msub></m:math>, the minimum mean square error estimator,
is the center of mass of the posterior. Seeing that <m:math overflow="scroll"><m:mrow><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:mo>-</m:mo><m:msub><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:mrow><m:mi>M</m:mi><m:mi>M</m:mi><m:mi>S</m:mi><m:mi>E</m:mi></m:mrow></m:msub></m:mrow></m:math>
and <m:math overflow="scroll"><m:mrow><m:mi>x</m:mi><m:mo>-</m:mo><m:msub><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:mrow><m:mi>M</m:mi><m:mi>M</m:mi><m:mi>S</m:mi><m:mi>E</m:mi></m:mrow></m:msub></m:mrow></m:math> are orthogonal,</para>
      <equation id="id69320">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mrow>
              <m:mi>E</m:mi>
              <m:mo>[</m:mo>
              <m:mo>∥</m:mo>
              <m:mi>x</m:mi>
            </m:mrow>
            <m:mo>-</m:mo>
            <m:mover accent="true">
              <m:mi>x</m:mi>
              <m:mo>ˆ</m:mo>
            </m:mover>
            <m:msubsup>
              <m:mrow>
                <m:mo>∥</m:mo>
              </m:mrow>
              <m:mn>2</m:mn>
              <m:mn>2</m:mn>
            </m:msubsup>
            <m:mrow>
              <m:mo>]</m:mo>
              <m:mo>=</m:mo>
              <m:mi>E</m:mi>
              <m:mo>[</m:mo>
              <m:mo>∥</m:mo>
              <m:mi>x</m:mi>
              <m:mo>-</m:mo>
            </m:mrow>
            <m:msub>
              <m:mover accent="true">
                <m:mi>x</m:mi>
                <m:mo>ˆ</m:mo>
              </m:mover>
              <m:mrow>
                <m:mi>M</m:mi>
                <m:mi>M</m:mi>
                <m:mi>S</m:mi>
                <m:mi>E</m:mi>
              </m:mrow>
            </m:msub>
            <m:msubsup>
              <m:mrow>
                <m:mo>∥</m:mo>
              </m:mrow>
              <m:mn>2</m:mn>
              <m:mn>2</m:mn>
            </m:msubsup>
            <m:mrow>
              <m:mo>]</m:mo>
              <m:mo>+</m:mo>
              <m:mi>E</m:mi>
              <m:mo>[</m:mo>
              <m:mo>∥</m:mo>
            </m:mrow>
            <m:msub>
              <m:mover accent="true">
                <m:mi>x</m:mi>
                <m:mo>ˆ</m:mo>
              </m:mover>
              <m:mrow>
                <m:mi>M</m:mi>
                <m:mi>M</m:mi>
                <m:mi>S</m:mi>
                <m:mi>E</m:mi>
              </m:mrow>
            </m:msub>
            <m:mo>-</m:mo>
            <m:mover accent="true">
              <m:mi>x</m:mi>
              <m:mo>ˆ</m:mo>
            </m:mover>
            <m:mrow>
              <m:msubsup>
                <m:mo>∥</m:mo>
                <m:mn>2</m:mn>
                <m:mn>2</m:mn>
              </m:msubsup>
              <m:mo>]</m:mo>
            </m:mrow>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id69474">and so <m:math overflow="scroll"><m:mrow><m:mi>E</m:mi><m:mo>[</m:mo><m:mo>∥</m:mo><m:mi>x</m:mi><m:mo>-</m:mo><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:msubsup><m:mo>∥</m:mo><m:mn>2</m:mn><m:mn>2</m:mn></m:msubsup><m:mo>]</m:mo></m:mrow></m:math>, the mean square error, is double the
MMSE <link target-id="bid14"/>.</para>
      <para id="id69526">Let us pause to reflect about this result. When the SNR is high, i.e.,
<m:math overflow="scroll"><m:mrow><m:msubsup><m:mrow><m:mo>∥</m:mo><m:mi>x</m:mi><m:mo>∥</m:mo></m:mrow><m:mn>2</m:mn><m:mn>2</m:mn></m:msubsup><m:mo>≫</m:mo><m:msubsup><m:mrow><m:mo>∥</m:mo><m:mi>z</m:mi><m:mo>∥</m:mo></m:mrow><m:mn>2</m:mn><m:mn>2</m:mn></m:msubsup></m:mrow></m:math>, the MMSE should be rather low, and double the MMSE seems pretty good.
On the other hand, when the SNR is low, the MMSE could be almost as large as <m:math overflow="scroll"><m:mrow><m:mi>E</m:mi><m:mo>[</m:mo><m:mo>∥</m:mo><m:mi>x</m:mi><m:msubsup><m:mo>∥</m:mo><m:mn>2</m:mn><m:mn>2</m:mn></m:msubsup><m:mo>]</m:mo></m:mrow></m:math>,
and double the MMSE could be larger – as much as twice larger – than <m:math overflow="scroll"><m:mrow><m:mi>E</m:mi><m:mo>[</m:mo><m:mo>∥</m:mo><m:mi>x</m:mi><m:msubsup><m:mo>∥</m:mo><m:mn>2</m:mn><m:mn>2</m:mn></m:msubsup><m:mo>]</m:mo></m:mrow></m:math>.
That is, gussing <m:math overflow="scroll"><m:mrow><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover><m:mo>=</m:mo><m:mi>E</m:mi><m:mrow><m:mo>[</m:mo><m:mi>x</m:mi><m:mo>]</m:mo></m:mrow></m:mrow></m:math> could give better signal estimation performance than using
the Kolmogorov sampler. This pessimistic result encourages us to search for better signal reconstruction methods.</para>
      <para id="id69665"><emphasis effect="bold">Arbitrary channels:</emphasis> So far we considered the Kolmogorov sampler for the white scalar channel, <m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>=</m:mo><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>z</m:mi></m:mrow></m:math>.
Suppose instead that <m:math overflow="scroll"><m:mi>x</m:mi></m:math> is processed or measured by a more complicated system,</para>
      <equation id="uid38">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>y</m:mi>
            <m:mo>=</m:mo>
            <m:mi>J</m:mi>
            <m:mo>(</m:mo>
            <m:mi>x</m:mi>
            <m:mo>)</m:mo>
            <m:mo>+</m:mo>
            <m:mi>z</m:mi>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id69734">Note that <m:math overflow="scroll"><m:mi>J</m:mi></m:math> is known, e.g., in a compressed sensing
application <link target-id="bid20"/>, <link target-id="bid21"/><m:math overflow="scroll"><m:mi>J</m:mi></m:math> would be a known matrix.
An even more involved system would be
<m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>=</m:mo><m:mo>(</m:mo><m:mi>J</m:mi><m:mo>⊗</m:mo><m:mi>x</m:mi><m:mo>)</m:mo><m:mo>⊕</m:mo><m:mi>z</m:mi></m:mrow></m:math>, where <m:math overflow="scroll"><m:mrow><m:mi>J</m:mi><m:mo>⊗</m:mo><m:mi>x</m:mi></m:mrow></m:math> is application of a mapping to x,
<m:math overflow="scroll"><m:mrow><m:mi>J</m:mi><m:mo>⊗</m:mo><m:mi>x</m:mi><m:mo>∈</m:mo><m:msup><m:mi mathvariant="double-struck">R</m:mi><m:mi>L</m:mi></m:msup></m:mrow></m:math>, and <m:math overflow="scroll"><m:mrow><m:mo>⊕</m:mo><m:mi>z</m:mi></m:mrow></m:math> denotes application of a random noise
operator to <m:math overflow="scroll"><m:mrow><m:mi>J</m:mi><m:mo>⊗</m:mo><m:mi>x</m:mi></m:mrow></m:math>.
To keep the presentation simple, we use the additive noise setting <link target-id="uid38"/>.</para><para id="id69870">How can the Kolmogorov sampler <link target-id="uid37"/> be applied to the additive noise setting?
Recall that for the scalar channel, the Kolmogorov sampler minimizes <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow></m:math>
subject to <m:math overflow="scroll"><m:mrow><m:msubsup><m:mrow><m:mo>∥</m:mo><m:mi>y</m:mi><m:mo>-</m:mo><m:mi>w</m:mi><m:mo>∥</m:mo></m:mrow><m:mn>2</m:mn><m:mn>2</m:mn></m:msubsup><m:mo>≤</m:mo><m:mi>n</m:mi></m:mrow></m:math>. For the arbitrary mapping <m:math overflow="scroll"><m:mi>J</m:mi></m:math> with additive noise <link target-id="uid38"/>,
this implies <m:math overflow="scroll"><m:mrow><m:msubsup><m:mrow><m:mo>∥</m:mo><m:mi>y</m:mi><m:mo>-</m:mo><m:mi>J</m:mi><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow><m:mo>∥</m:mo></m:mrow><m:mn>2</m:mn><m:mn>2</m:mn></m:msubsup><m:mo>≤</m:mo><m:mi>n</m:mi></m:mrow></m:math>. Therefore, we get</para>
      <equation id="id69982">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mover accent="true">
              <m:mi>x</m:mi>
              <m:mo>ˆ</m:mo>
            </m:mover>
            <m:mo>=</m:mo>
            <m:munder>
              <m:mrow>
                <m:mo form="prefix">arg</m:mo>
                <m:mo movablelimits="true" form="prefix">min</m:mo>
              </m:mrow>
              <m:mrow>
                <m:msubsup>
                  <m:mrow>
                    <m:mi>s</m:mi>
                    <m:mo>.</m:mo>
                    <m:mi>t</m:mi>
                    <m:mo>.</m:mo>
                    <m:mo>∥</m:mo>
                    <m:mi>Y</m:mi>
                    <m:mo>-</m:mo>
                    <m:mi>J</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>w</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>∥</m:mo>
                  </m:mrow>
                  <m:mn>2</m:mn>
                  <m:mn>2</m:mn>
                </m:msubsup>
                <m:mo>≤</m:mo>
                <m:mi>n</m:mi>
              </m:mrow>
            </m:munder>
            <m:mi>K</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id70073">Another similar approach relies on optimization via Lagrange multipliers,</para>
      <equation id="uid39">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mover accent="true">
              <m:mi>x</m:mi>
              <m:mo>ˆ</m:mo>
            </m:mover>
            <m:mo>=</m:mo>
            <m:mrow>
              <m:mo form="prefix">arg</m:mo>
              <m:mo movablelimits="true" form="prefix">min</m:mo>
            </m:mrow>
            <m:mi>K</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>-</m:mo>
            <m:msub>
              <m:mo form="prefix">log</m:mo>
              <m:mn>2</m:mn>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msub>
                <m:mi>f</m:mi>
                <m:mi>z</m:mi>
              </m:msub>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>y</m:mi>
                <m:mo>-</m:mo>
                <m:mi>J</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>w</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id70172">where the lagrange multiplier is 1, because both <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow></m:math> and <m:math overflow="scroll"><m:mrow><m:msub><m:mo form="prefix">log</m:mo><m:mn>2</m:mn></m:msub><m:mrow><m:mo>(</m:mo><m:msub><m:mi>f</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>-</m:mo><m:mi>J</m:mi><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:math> are quantified in bits.</para>
      <para id="id70244">What is the performance of the Kolmogorov sampler for an arbitrary <m:math overflow="scroll"><m:mi>J</m:mi></m:math>?
We speculate <link target-id="bid22"/>, <link target-id="bid23"/>
that <m:math overflow="scroll"><m:mover accent="true"><m:mi>x</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> is generated by the posterior, and so <m:math overflow="scroll"><m:mrow><m:mi>E</m:mi><m:mo>[</m:mo><m:mo>∥</m:mo><m:mi>x</m:mi><m:mo>-</m:mo><m:msubsup><m:mover accent="true"><m:mo>∥</m:mo><m:mo>ˆ</m:mo></m:mover><m:mn>2</m:mn><m:mn>2</m:mn></m:msubsup><m:mo>]</m:mo></m:mrow></m:math> is double the MMSE, where expectation is taken over the source <m:math overflow="scroll"><m:mi>X</m:mi></m:math> and noise <m:math overflow="scroll"><m:mi>z</m:mi></m:math>. These results remain to be shown rigorously.</para>
    </section>
    <section id="uid40">
      <title>Convergence of MCMC algorithm</title>
      <para id="id70351">We will now prove a substantial result – that the MCMC
algorithm <link target-id="bid8"/>, <link target-id="bid10"/>, <link target-id="bid23"/>
converges to the globally minimal energy solution
for the specific case of compressed sensing <link target-id="bid20"/>, <link target-id="bid21"/>.
An extension of this proof to arbitrary channels <m:math overflow="scroll"><m:mi>J</m:mi></m:math> is in progress.</para>
      <para id="id70394">If the operator <m:math overflow="scroll"><m:mi>J</m:mi></m:math> in <link target-id="uid38"/> is a matrix, and we denote it by <m:math overflow="scroll"><m:mrow><m:mo>Φ</m:mo><m:mo>∈</m:mo><m:msup><m:mi mathvariant="double-struck">R</m:mi><m:mrow><m:mi>m</m:mi><m:mo>×</m:mo><m:mi>n</m:mi></m:mrow></m:msup></m:mrow></m:math> where <m:math overflow="scroll"><m:mrow><m:mi>m</m:mi><m:mo>≪</m:mo><m:mi>n</m:mi></m:mrow></m:math>, then the setup is known as compressed
sensing (CS) <link target-id="bid20"/>, <link target-id="bid21"/>
and the estimation problem is commonly referred to as recovery
or reconstruction.
By posing a sparsity or compressibility requirement on the signal and using it as a prior
during recovery, it is indeed possible to accurately estimate
<m:math overflow="scroll"><m:mi>x</m:mi></m:math> from <m:math overflow="scroll"><m:mi>y</m:mi></m:math> in the CS setting.</para><para id="id70485">With the quantization alphabet definition in <link target-id="uid29"/>, <m:math overflow="scroll"><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> will quantize
<m:math overflow="scroll"><m:mi>x</m:mi></m:math> to a greater resolution as <m:math overflow="scroll"><m:mi>N</m:mi></m:math> increases. We will show that under suitable conditions on <m:math overflow="scroll"><m:msub><m:mi>f</m:mi><m:mi>X</m:mi></m:msub></m:math>, performing maximum <emphasis effect="italics">a
posteriori</emphasis> (MAP) estimation over the discrete alphabet <m:math overflow="scroll"><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover></m:math> asymptotically
converges to the MAP estimate over the continuous distribution <m:math overflow="scroll"><m:msub><m:mi>f</m:mi><m:mi>X</m:mi></m:msub></m:math>. This reduces
the complexity of the estimation problem from continuous to discrete.</para>
      <para id="id70578">We assume for exposition that we know the input statistics <m:math overflow="scroll"><m:msub><m:mi>f</m:mi><m:mi>X</m:mi></m:msub></m:math>.
Given the measurements <m:math overflow="scroll"><m:mi>y</m:mi></m:math>, the MAP estimator for <m:math overflow="scroll"><m:mi>x</m:mi></m:math> has the form</para>
      <equation id="uid41">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>x</m:mi>
              <m:mrow>
                <m:mi>M</m:mi>
                <m:mi>A</m:mi>
                <m:mi>P</m:mi>
              </m:mrow>
            </m:msub>
            <m:mo>≜</m:mo>
            <m:munder>
              <m:mrow>
                <m:mo form="prefix">arg</m:mo>
                <m:mo movablelimits="true" form="prefix">max</m:mo>
              </m:mrow>
              <m:mi>w</m:mi>
            </m:munder>
            <m:msub>
              <m:mi>f</m:mi>
              <m:mi>X</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:msub>
              <m:mi>f</m:mi>
              <m:mrow>
                <m:mi>Y</m:mi>
                <m:mo>|</m:mo>
                <m:mi>X</m:mi>
              </m:mrow>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>y</m:mi>
              <m:mo>|</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id70702">Because <m:math overflow="scroll"><m:mi>z</m:mi></m:math> is i.i.d. Gaussian with mean zero and known variance <m:math overflow="scroll"><m:msubsup><m:mi>σ</m:mi><m:mi>Z</m:mi><m:mn>2</m:mn></m:msubsup></m:math>,</para>
      <equation id="uid42">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>f</m:mi>
              <m:mrow>
                <m:mi>Y</m:mi>
                <m:mo>|</m:mo>
                <m:mi>X</m:mi>
              </m:mrow>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>y</m:mi>
              <m:mo>|</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:msub>
              <m:mi>c</m:mi>
              <m:mn>1</m:mn>
            </m:msub>
            <m:msup>
              <m:mi>e</m:mi>
              <m:mrow>
                <m:mo>-</m:mo>
                <m:msub>
                  <m:mi>c</m:mi>
                  <m:mn>2</m:mn>
                </m:msub>
                <m:msup>
                  <m:mrow>
                    <m:mo>∥</m:mo>
                    <m:mi>y</m:mi>
                    <m:mo>-</m:mo>
                    <m:mi>Φ</m:mi>
                    <m:mi>w</m:mi>
                    <m:mo>∥</m:mo>
                  </m:mrow>
                  <m:mn>2</m:mn>
                </m:msup>
              </m:mrow>
            </m:msup>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id70820">where
<m:math overflow="scroll"><m:mrow><m:msub><m:mi>c</m:mi><m:mn>1</m:mn></m:msub><m:mo>=</m:mo><m:msup><m:mrow><m:mo>(</m:mo><m:mn>2</m:mn><m:mi>π</m:mi><m:msubsup><m:mi>σ</m:mi><m:mi>Z</m:mi><m:mn>2</m:mn></m:msubsup><m:mo>)</m:mo></m:mrow><m:mrow><m:mo>-</m:mo><m:mi>M</m:mi><m:mo>/</m:mo><m:mn>2</m:mn></m:mrow></m:msup></m:mrow></m:math> and
<m:math overflow="scroll"><m:mrow><m:msub><m:mi>c</m:mi><m:mn>2</m:mn></m:msub><m:mo>=</m:mo><m:mfrac><m:mn>1</m:mn><m:mrow><m:mn>2</m:mn><m:msubsup><m:mi>σ</m:mi><m:mi>Z</m:mi><m:mn>2</m:mn></m:msubsup></m:mrow></m:mfrac></m:mrow></m:math>
are constants and <m:math overflow="scroll"><m:mrow><m:mo>∥</m:mo><m:mo>·</m:mo><m:mo>∥</m:mo></m:mrow></m:math> denotes the Euclidean norm.
Plugging into <link target-id="uid41"/> and taking log likelihoods, we obtain</para>
      <equation id="uid43">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msub>
                    <m:mi>x</m:mi>
                    <m:mrow>
                      <m:mi>M</m:mi>
                      <m:mi>A</m:mi>
                      <m:mi>P</m:mi>
                    </m:mrow>
                  </m:msub>
                  <m:mo>=</m:mo>
                  <m:munder>
                    <m:mrow>
                      <m:mo form="prefix">arg</m:mo>
                      <m:mo movablelimits="true" form="prefix">min</m:mo>
                    </m:mrow>
                    <m:mi>w</m:mi>
                  </m:munder>
                  <m:msup>
                    <m:mi>Ψ</m:mi>
                    <m:mi>X</m:mi>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>,</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id71005">where <m:math overflow="scroll"><m:mrow><m:msup><m:mo>Ψ</m:mo><m:mi>X</m:mi></m:msup><m:mrow><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow></m:mrow></m:math> denotes the objective function (risk)</para><equation id="uid44"><m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msup>
              <m:mo>Ψ</m:mo>
              <m:mi>X</m:mi>
            </m:msup>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>≜</m:mo>
            <m:mo>-</m:mo>
            <m:mo form="prefix">ln</m:mo>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msub>
                <m:mi>f</m:mi>
                <m:mi>X</m:mi>
              </m:msub>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>w</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>+</m:mo>
            <m:msub>
              <m:mi>c</m:mi>
              <m:mn>2</m:mn>
            </m:msub>
            <m:msup>
              <m:mrow>
                <m:mo>∥</m:mo>
                <m:mi>y</m:mi>
                <m:mo>-</m:mo>
                <m:mo>Φ</m:mo>
                <m:mi>w</m:mi>
                <m:mo>∥</m:mo>
              </m:mrow>
              <m:mn>2</m:mn>
            </m:msup>
            <m:mo>;</m:mo>
          </m:mrow>
        </m:math>
      </equation><para id="id71124">our ideal risk would be <m:math overflow="scroll"><m:mrow><m:msup><m:mo>Ψ</m:mo><m:mi>X</m:mi></m:msup><m:mrow><m:mo>(</m:mo><m:msub><m:mi>x</m:mi><m:mrow><m:mi>M</m:mi><m:mi>A</m:mi><m:mi>P</m:mi></m:mrow></m:msub><m:mo>)</m:mo></m:mrow></m:mrow></m:math>.</para><para id="id71164">Instead of performing continuous-valued MAP estimation, we optimize for the MAP
in the discretized domain <m:math overflow="scroll"><m:msup><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>N</m:mi></m:msup></m:math>. We begin with a technical condition on
the input.</para>
      <para id="id71189"><emphasis effect="bold">Condition 1 <link target-id="bid23"/></emphasis> 

We require that the probability density has bounded derivatives</para>
      <equation id="uid46">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mfenced separators="" open="|" close="|">
              <m:mfrac>
                <m:mi>d</m:mi>
                <m:mrow>
                  <m:mi>d</m:mi>
                  <m:msub>
                    <m:mi>x</m:mi>
                    <m:mi>n</m:mi>
                  </m:msub>
                </m:mrow>
              </m:mfrac>
              <m:mo form="prefix">ln</m:mo>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msub>
                  <m:mi>f</m:mi>
                  <m:mi>X</m:mi>
                </m:msub>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>x</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:mfenced>
            <m:mo>&lt;</m:mo>
            <m:mi>ρ</m:mi>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id71276">where <m:math overflow="scroll"><m:mfrac><m:mi>d</m:mi><m:mrow><m:mi>d</m:mi><m:msub><m:mi>x</m:mi><m:mi>n</m:mi></m:msub></m:mrow></m:mfrac></m:math> is the derivative w.r.t. entry <m:math overflow="scroll"><m:mi>n</m:mi></m:math> of <m:math overflow="scroll"><m:mi>x</m:mi></m:math>,
<m:math overflow="scroll"><m:mrow><m:mi>n</m:mi><m:mo>∈</m:mo><m:mo>{</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:mi>N</m:mi><m:mo>}</m:mo></m:mrow></m:math>, and <m:math overflow="scroll"><m:mrow><m:mi>ρ</m:mi><m:mo>&gt;</m:mo><m:mn>0</m:mn></m:mrow></m:math>.</para>
      <para id="id71363">Let <m:math overflow="scroll"><m:msub><m:mover accent="true"><m:mi>x</m:mi><m:mo>˜</m:mo></m:mover><m:mrow><m:mi>M</m:mi><m:mi>A</m:mi><m:mi>P</m:mi></m:mrow></m:msub></m:math> be the quantization bin in <m:math overflow="scroll"><m:msup><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>N</m:mi></m:msup></m:math> nearest to
<m:math overflow="scroll"><m:msub><m:mi>x</m:mi><m:mrow><m:mi>M</m:mi><m:mi>A</m:mi><m:mi>P</m:mi></m:mrow></m:msub></m:math>. <link target-id="id71189">Condition 1</link> ensures that a small perturbation from
<m:math overflow="scroll"><m:msub><m:mi>x</m:mi><m:mrow><m:mi>M</m:mi><m:mi>A</m:mi><m:mi>P</m:mi></m:mrow></m:msub></m:math> to <m:math overflow="scroll"><m:msub><m:mover accent="true"><m:mi>x</m:mi><m:mo>˜</m:mo></m:mover><m:mrow><m:mi>M</m:mi><m:mi>A</m:mi><m:mi>P</m:mi></m:mrow></m:msub></m:math> does
not change <m:math overflow="scroll"><m:mrow><m:mo form="prefix">ln</m:mo><m:mo>(</m:mo><m:msub><m:mi>f</m:mi><m:mi>X</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mo>·</m:mo><m:mo>)</m:mo></m:mrow><m:mo>)</m:mo></m:mrow></m:math> by much.
We use this fact to prove that <m:math overflow="scroll"><m:mrow><m:msup><m:mo>Ψ</m:mo><m:mi>X</m:mi></m:msup><m:mrow><m:mo>(</m:mo><m:msub><m:mover accent="true"><m:mi>x</m:mi><m:mo>˜</m:mo></m:mover><m:mrow><m:mi>M</m:mi><m:mi>A</m:mi><m:mi>P</m:mi></m:mrow></m:msub><m:mo>)</m:mo></m:mrow></m:mrow></m:math>
is sufficiently close to <m:math overflow="scroll"><m:mrow><m:msup><m:mo>Ψ</m:mo><m:mi>X</m:mi></m:msup><m:mrow><m:mo>(</m:mo><m:msub><m:mi>x</m:mi><m:mrow><m:mi>M</m:mi><m:mi>A</m:mi><m:mi>P</m:mi></m:mrow></m:msub><m:mo>)</m:mo></m:mrow></m:mrow></m:math> asymptotically.</para><para id="id71590"><emphasis effect="bold">Theorem 9 <link target-id="bid23"/></emphasis> 
Let <m:math overflow="scroll"><m:mrow><m:mo>Φ</m:mo><m:mo>∈</m:mo><m:msup><m:mi mathvariant="double-struck">R</m:mi><m:mrow><m:mi>M</m:mi><m:mo>×</m:mo><m:mi>N</m:mi></m:mrow></m:msup></m:mrow></m:math> be an i.i.d. Gaussian measurement matrix
where each entry has mean zero and variance <m:math overflow="scroll"><m:mfrac><m:mn>1</m:mn><m:mi>M</m:mi></m:mfrac></m:math>. Suppose that
<link target-id="id71189">Condition 1</link> holds and the aspect ratio <m:math overflow="scroll"><m:mrow><m:mi>δ</m:mi><m:mo>=</m:mo><m:mfrac><m:mi>m</m:mi><m:mi>n</m:mi></m:mfrac><m:mo>&gt;</m:mo><m:mn>0</m:mn></m:mrow></m:math>, and let the noise <m:math overflow="scroll"><m:mrow><m:mi>z</m:mi><m:mo>∈</m:mo><m:msup><m:mi mathvariant="double-struck">R</m:mi><m:mi>M</m:mi></m:msup></m:mrow></m:math> be i.i.d. zero-mean
Gaussian.
Then for all <m:math overflow="scroll"><m:mrow><m:mi>ϵ</m:mi><m:mo>&gt;</m:mo><m:mn>0</m:mn></m:mrow></m:math>, the quantized estimator <m:math overflow="scroll"><m:msub><m:mover accent="true"><m:mi>x</m:mi><m:mo>˜</m:mo></m:mover><m:mrow><m:mi>M</m:mi><m:mi>A</m:mi><m:mi>P</m:mi></m:mrow></m:msub></m:math> satisfies</para><equation id="uid48"><m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msup>
                    <m:mo>Ψ</m:mo>
                    <m:mi>X</m:mi>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mi>M</m:mi>
                        <m:mi>A</m:mi>
                        <m:mi>P</m:mi>
                      </m:mrow>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≤</m:mo>
                  <m:msup>
                    <m:mo>Ψ</m:mo>
                    <m:mi>X</m:mi>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mover accent="true">
                        <m:mi>x</m:mi>
                        <m:mo>˜</m:mo>
                      </m:mover>
                      <m:mrow>
                        <m:mi>M</m:mi>
                        <m:mi>A</m:mi>
                        <m:mi>P</m:mi>
                      </m:mrow>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>&lt;</m:mo>
                  <m:msup>
                    <m:mo>Ψ</m:mo>
                    <m:mi>X</m:mi>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mi>M</m:mi>
                        <m:mi>A</m:mi>
                        <m:mi>P</m:mi>
                      </m:mrow>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>+</m:mo>
                  <m:mi>N</m:mi>
                  <m:mi>ϵ</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation><para id="id71858">
almost surely as <m:math overflow="scroll"><m:mrow><m:mi>N</m:mi><m:mo>→</m:mo><m:mi>∞</m:mi></m:mrow></m:math>.</para>
      <para id="id71879">Given that <link target-id="id71590">Theorem 9</link> shows that the risk penalty due
to quantization vanishes asymptotically in <m:math overflow="scroll"><m:mi>n</m:mi></m:math>,
we now describe a Kolmogorov-inspired estimator
for CS over a quantized grid. We define the energy <m:math overflow="scroll"><m:mrow><m:mi>ϵ</m:mi><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow></m:math>:</para><equation id="uid49"><m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>ϵ</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>n</m:mi>
              </m:msup>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>≜</m:mo>
            <m:mi>n</m:mi>
            <m:msub>
              <m:mi>H</m:mi>
              <m:mi>k</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>n</m:mi>
              </m:msup>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>+</m:mo>
            <m:msub>
              <m:mi>c</m:mi>
              <m:mn>4</m:mn>
            </m:msub>
            <m:msup>
              <m:mrow>
                <m:mo>∥</m:mo>
                <m:msup>
                  <m:mi>y</m:mi>
                  <m:mi>m</m:mi>
                </m:msup>
                <m:mo>-</m:mo>
                <m:mo>Φ</m:mo>
                <m:msup>
                  <m:mi>w</m:mi>
                  <m:mi>n</m:mi>
                </m:msup>
                <m:mo>∥</m:mo>
              </m:mrow>
              <m:mn>2</m:mn>
            </m:msup>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation><para id="id72015">where <m:math overflow="scroll"><m:mrow><m:msub><m:mi>c</m:mi><m:mn>4</m:mn></m:msub><m:mo>=</m:mo><m:msub><m:mi>c</m:mi><m:mn>2</m:mn></m:msub><m:msub><m:mo form="prefix">log</m:mo><m:mn>2</m:mn></m:msub><m:mrow><m:mo>(</m:mo><m:mi>e</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>.</para>
      <para id="id72063">Ideally, our goal is to compute the globally minimum energy solution</para>
      <equation id="uid50">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msubsup>
              <m:mi>x</m:mi>
              <m:mrow>
                <m:mi>M</m:mi>
                <m:mi>A</m:mi>
                <m:mi>P</m:mi>
              </m:mrow>
              <m:msub>
                <m:mi>H</m:mi>
                <m:mi>k</m:mi>
              </m:msub>
            </m:msubsup>
            <m:mo>≜</m:mo>
            <m:munder>
              <m:mrow>
                <m:mo form="prefix">arg</m:mo>
                <m:mo movablelimits="true" form="prefix">min</m:mo>
              </m:mrow>
              <m:mrow>
                <m:msup>
                  <m:mi>w</m:mi>
                  <m:mi>n</m:mi>
                </m:msup>
                <m:mo>∈</m:mo>
                <m:msup>
                  <m:mover accent="true">
                    <m:mi>α</m:mi>
                    <m:mo>ˆ</m:mo>
                  </m:mover>
                  <m:mi>n</m:mi>
                </m:msup>
              </m:mrow>
            </m:munder>
            <m:mi>ϵ</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>n</m:mi>
              </m:msup>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id72162"><emphasis effect="bold">Theorem 10 <link target-id="bid23"/></emphasis> 
Let <m:math overflow="scroll"><m:mi>X</m:mi></m:math> be a bounded stationary ergodic source. Then the outcome <m:math overflow="scroll"><m:msubsup><m:mi>w</m:mi><m:mi>r</m:mi><m:mi>n</m:mi></m:msubsup></m:math> of
Algorithm 1 after <m:math overflow="scroll"><m:mi>r</m:mi></m:math> iterations obeys</para><equation id="uid52">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">lim</m:mo>
                    <m:mrow>
                      <m:mi>r</m:mi>
                      <m:mo>→</m:mo>
                      <m:mi>∞</m:mi>
                    </m:mrow>
                  </m:munder>
                  <m:mi>ϵ</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msubsup>
                      <m:mi>w</m:mi>
                      <m:mi>r</m:mi>
                      <m:mi>n</m:mi>
                    </m:msubsup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">min</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>v</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>∈</m:mo>
                      <m:msup>
                        <m:mover accent="true">
                          <m:mi>α</m:mi>
                          <m:mo>ˆ</m:mo>
                        </m:mover>
                        <m:mi>n</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:munder>
                  <m:mi>ϵ</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>v</m:mi>
                      <m:mi>n</m:mi>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:mi>ϵ</m:mi>
                  <m:mfenced separators="" open="(" close=")">
                    <m:msubsup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mi>M</m:mi>
                        <m:mi>A</m:mi>
                        <m:mi>P</m:mi>
                      </m:mrow>
                      <m:msub>
                        <m:mi>H</m:mi>
                        <m:mi>k</m:mi>
                      </m:msub>
                    </m:msubsup>
                  </m:mfenced>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id72369">We define a stochastic transition matrix <m:math overflow="scroll"><m:msub><m:mi>P</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub></m:math> from <m:math overflow="scroll"><m:msup><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>n</m:mi></m:msup></m:math> to itself given by the Boltzmann distribution for super-iteration <m:math overflow="scroll"><m:mi>r</m:mi></m:math>. Similarly, <m:math overflow="scroll"><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub></m:math> defines the stable state distribution on <m:math overflow="scroll"><m:msup><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>n</m:mi></m:msup></m:math> for <m:math overflow="scroll"><m:msub><m:mi>P</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub></m:math>, satisfying <m:math overflow="scroll"><m:mrow><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:msub><m:mi>P</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub></m:mrow></m:math>.</para>
      <para id="id72532"><emphasis effect="bold">Definition 4 <link target-id="bid24"/></emphasis><emphasis effect="italics">The Dobrushin's ergodic coefficient</emphasis> of a Markov chain transition matrix <m:math overflow="scroll"><m:mi>P</m:mi></m:math> is denoted by <m:math overflow="scroll"><m:mrow><m:mi>δ</m:mi><m:mo>(</m:mo><m:mi>P</m:mi><m:mo>)</m:mo></m:mrow></m:math> and defined as</para><equation id="uid54">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mi>δ</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>P</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≜</m:mo>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">max</m:mo>
                    <m:mrow>
                      <m:mn>1</m:mn>
                      <m:mo>≤</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>,</m:mo>
                      <m:mi>j</m:mi>
                      <m:mo>≤</m:mo>
                      <m:mi>N</m:mi>
                    </m:mrow>
                  </m:munder>
                  <m:mfrac>
                    <m:mn>1</m:mn>
                    <m:mn>2</m:mn>
                  </m:mfrac>
                  <m:msub>
                    <m:mrow>
                      <m:mo>∥</m:mo>
                      <m:msub>
                        <m:mi>p</m:mi>
                        <m:mi>i</m:mi>
                      </m:msub>
                      <m:mo>-</m:mo>
                      <m:msub>
                        <m:mi>p</m:mi>
                        <m:mi>j</m:mi>
                      </m:msub>
                      <m:mo>∥</m:mo>
                    </m:mrow>
                    <m:mn>1</m:mn>
                  </m:msub>
                  <m:mo>,</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id72678">
where <m:math overflow="scroll"><m:msub><m:mi>p</m:mi><m:mi>i</m:mi></m:msub></m:math> denotes the <m:math overflow="scroll"><m:msup><m:mi>i</m:mi><m:mrow><m:mi>t</m:mi><m:mi>h</m:mi></m:mrow></m:msup></m:math> row of <m:math overflow="scroll"><m:mi>P</m:mi></m:math>, <m:math overflow="scroll"><m:mrow><m:mn>1</m:mn><m:mo>≤</m:mo><m:mi>n</m:mi><m:mo>≤</m:mo><m:mi>N</m:mi></m:mrow></m:math>.</para>
      <para id="id72743">From the definition, <m:math overflow="scroll"><m:mrow><m:mn>0</m:mn><m:mo>≤</m:mo><m:mi>δ</m:mi><m:mo>(</m:mo><m:mi>P</m:mi><m:mo>)</m:mo><m:mo>≤</m:mo><m:mn>1</m:mn></m:mrow></m:math>. Moreover, the ergodic coefficient can be rewritten as</para>
      <equation id="uid55">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mi>δ</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>P</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>-</m:mo>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">min</m:mo>
                    <m:mrow>
                      <m:mn>1</m:mn>
                      <m:mo>≤</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>,</m:mo>
                      <m:mi>j</m:mi>
                      <m:mo>≤</m:mo>
                      <m:mi>N</m:mi>
                    </m:mrow>
                  </m:munder>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>k</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>N</m:mi>
                  </m:munderover>
                  <m:mo movablelimits="true" form="prefix">min</m:mo>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>p</m:mi>
                      <m:mrow>
                        <m:mi>i</m:mi>
                        <m:mi>k</m:mi>
                      </m:mrow>
                    </m:msub>
                    <m:mo>,</m:mo>
                    <m:msub>
                      <m:mi>p</m:mi>
                      <m:mrow>
                        <m:mi>j</m:mi>
                        <m:mi>k</m:mi>
                      </m:mrow>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>,</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id72890">
where <m:math overflow="scroll"><m:msub><m:mi>p</m:mi><m:mrow><m:mi>i</m:mi><m:mi>j</m:mi></m:mrow></m:msub></m:math> denotes the entry of <m:math overflow="scroll"><m:mi>P</m:mi></m:math> at the <m:math overflow="scroll"><m:msup><m:mi>i</m:mi><m:mrow><m:mi>t</m:mi><m:mi>h</m:mi></m:mrow></m:msup></m:math> row and <m:math overflow="scroll"><m:msup><m:mi>j</m:mi><m:mrow><m:mi>t</m:mi><m:mi>h</m:mi></m:mrow></m:msup></m:math> column.</para>
      <para id="id72957">We group the product of transition matrices
across super-iterations as</para>
      <equation id="id72961">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>P</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msub>
                  <m:mi>r</m:mi>
                  <m:mn>1</m:mn>
                </m:msub>
                <m:mo>→</m:mo>
                <m:msub>
                  <m:mi>r</m:mi>
                  <m:mn>2</m:mn>
                </m:msub>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msub>
            <m:mo>=</m:mo>
            <m:munderover>
              <m:mo>∏</m:mo>
              <m:mrow>
                <m:mi>r</m:mi>
                <m:mo>=</m:mo>
                <m:msub>
                  <m:mi>r</m:mi>
                  <m:mn>1</m:mn>
                </m:msub>
              </m:mrow>
              <m:msub>
                <m:mi>r</m:mi>
                <m:mn>2</m:mn>
              </m:msub>
            </m:munderover>
            <m:msub>
              <m:mi>P</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>r</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msub>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id73042">There are two common characterizations for the stable-state behavior of a non-homogeneous MC.</para>
      <para id="id73048"><emphasis effect="bold">Definition 5 <link target-id="bid24"/></emphasis> 
A non-homogeneous MC is called <emphasis effect="italics">weakly ergodic</emphasis> if for any distributions <m:math overflow="scroll"><m:mi>μ</m:mi></m:math> and <m:math overflow="scroll"><m:mi>ν</m:mi></m:math> over the state space <m:math overflow="scroll"><m:mi mathvariant="script">S</m:mi></m:math>, and any <m:math overflow="scroll"><m:mrow><m:msub><m:mi>r</m:mi><m:mn>1</m:mn></m:msub><m:mo>∈</m:mo><m:mi mathvariant="double-struck">N</m:mi></m:mrow></m:math>,</para><equation id="uid57">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msub>
                    <m:mrow>
                      <m:mo movablelimits="true" form="prefix">lim</m:mo>
                      <m:mo movablelimits="true" form="prefix">sup</m:mo>
                    </m:mrow>
                    <m:mrow>
                      <m:msub>
                        <m:mi>r</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                      <m:mo>→</m:mo>
                      <m:mi>∞</m:mi>
                    </m:mrow>
                  </m:msub>
                  <m:msub>
                    <m:mrow>
                      <m:mo>∥</m:mo>
                      <m:mi>μ</m:mi>
                      <m:msub>
                        <m:mi>P</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msub>
                            <m:mi>r</m:mi>
                            <m:mn>1</m:mn>
                          </m:msub>
                          <m:mo>→</m:mo>
                          <m:msub>
                            <m:mi>r</m:mi>
                            <m:mn>2</m:mn>
                          </m:msub>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                      <m:mo>-</m:mo>
                      <m:mi>ν</m:mi>
                      <m:msub>
                        <m:mi>P</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msub>
                            <m:mi>r</m:mi>
                            <m:mn>1</m:mn>
                          </m:msub>
                          <m:mo>→</m:mo>
                          <m:msub>
                            <m:mi>r</m:mi>
                            <m:mn>2</m:mn>
                          </m:msub>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                      <m:mo>∥</m:mo>
                    </m:mrow>
                    <m:mn>1</m:mn>
                  </m:msub>
                  <m:mo>=</m:mo>
                  <m:mn>0</m:mn>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id73256">
Similarly, a non-homogeneous MC is called <emphasis effect="italics">strongly ergodic</emphasis> if there exists a distribution <m:math overflow="scroll"><m:mi>π</m:mi></m:math> over the state space <m:math overflow="scroll"><m:mi mathvariant="script">S</m:mi></m:math> such that for any distribution <m:math overflow="scroll"><m:mi>μ</m:mi></m:math> over <m:math overflow="scroll"><m:mi mathvariant="script">S</m:mi></m:math>, and any <m:math overflow="scroll"><m:mrow><m:msub><m:mi>r</m:mi><m:mn>1</m:mn></m:msub><m:mo>∈</m:mo><m:mi mathvariant="double-struck">N</m:mi></m:mrow></m:math>,</para>
      <equation id="uid58">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msub>
                    <m:mrow>
                      <m:mo movablelimits="true" form="prefix">lim</m:mo>
                      <m:mo movablelimits="true" form="prefix">sup</m:mo>
                    </m:mrow>
                    <m:mrow>
                      <m:msub>
                        <m:mi>r</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                      <m:mo>→</m:mo>
                      <m:mi>∞</m:mi>
                    </m:mrow>
                  </m:msub>
                  <m:msub>
                    <m:mrow>
                      <m:mo>∥</m:mo>
                      <m:mi>μ</m:mi>
                      <m:msub>
                        <m:mi>P</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msub>
                            <m:mi>r</m:mi>
                            <m:mn>1</m:mn>
                          </m:msub>
                          <m:mo>→</m:mo>
                          <m:msub>
                            <m:mi>r</m:mi>
                            <m:mn>2</m:mn>
                          </m:msub>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                      <m:mo>-</m:mo>
                      <m:mi>π</m:mi>
                      <m:mo>∥</m:mo>
                    </m:mrow>
                    <m:mn>1</m:mn>
                  </m:msub>
                  <m:mo>=</m:mo>
                  <m:mn>0</m:mn>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id73436">
We will use the following two theorems from <link target-id="bid24"/> in our proof.</para>
      <para id="id73448"><emphasis effect="bold">Theorem 11 <link target-id="bid24"/></emphasis> 
A Markov chain is weakly ergodic if and only if there exists a sequence of integers <m:math overflow="scroll"><m:mrow><m:mn>0</m:mn><m:mo>≤</m:mo><m:msub><m:mi>r</m:mi><m:mn>1</m:mn></m:msub><m:mo>≤</m:mo><m:msub><m:mi>r</m:mi><m:mn>2</m:mn></m:msub><m:mo>≤</m:mo><m:mo>...</m:mo></m:mrow></m:math> such that</para><equation id="uid60">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>∞</m:mi>
                  </m:munderover>
                  <m:mfenced separators="" open="(" close=")">
                    <m:mn>1</m:mn>
                    <m:mo>-</m:mo>
                    <m:mi>δ</m:mi>
                    <m:mfenced separators="" open="(" close=")">
                      <m:msub>
                        <m:mi>P</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msub>
                            <m:mi>r</m:mi>
                            <m:mi>i</m:mi>
                          </m:msub>
                          <m:mo>→</m:mo>
                          <m:msub>
                            <m:mi>r</m:mi>
                            <m:mrow>
                              <m:mi>i</m:mi>
                              <m:mo>+</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:msub>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                    </m:mfenced>
                  </m:mfenced>
                  <m:mo>=</m:mo>
                  <m:mi>∞</m:mi>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id73600"><emphasis effect="bold">Theorem 12 <link target-id="bid24"/></emphasis> 
Let a Markov chain be weakly ergodic.
Assume that there exists a sequence of probability distributions <m:math overflow="scroll"><m:msubsup><m:mrow><m:mo>{</m:mo><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow><m:mi>∞</m:mi></m:msubsup></m:math> on the state space <m:math overflow="scroll"><m:mi mathvariant="script">S</m:mi></m:math> such that <m:math overflow="scroll"><m:mrow><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:msub><m:mi>P</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub></m:mrow></m:math>.
Then the Markov chain is strongly ergodic if</para><equation id="uid62">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>r</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>∞</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mrow>
                      <m:mo>∥</m:mo>
                      <m:msub>
                        <m:mi>π</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>r</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                      <m:mo>-</m:mo>
                      <m:msub>
                        <m:mi>π</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>r</m:mi>
                          <m:mo>+</m:mo>
                          <m:mn>1</m:mn>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                      <m:mo>∥</m:mo>
                    </m:mrow>
                    <m:mn>1</m:mn>
                  </m:msub>
                  <m:mo>&lt;</m:mo>
                  <m:mi>∞</m:mi>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id73807">The rest of proof is structured as follows. First, we show that the sequence of stable state distributions for the Markov chains (MC) used by the MCMC algorithm converges to a uniform distribution over the set of sequences that minimize the energy function as the iteration count <m:math overflow="scroll"><m:mi>t</m:mi></m:math> increases. Then, we show using <link target-id="id73448">Theorem 11</link> and <link target-id="id73600">Theorem 12</link> that the non-homogeneous MC used in the MCMC algorithm is strongly ergodic, which by the definition of strong ergodicity implies that MCMC always converges to the stable distribution found above. This implies that the outcome of the MCMC algorithm converges to a minimum-energy solution as <m:math overflow="scroll"><m:mrow><m:mi>t</m:mi><m:mo>→</m:mo><m:mi>∞</m:mi></m:mrow></m:math>, completing the proof of Theorem <link target-id="id72162">Theorem 10</link>.</para><para id="id73854">We therefore begin by finding the stable state distribution for the non-homogeneous MC
used by the MCMC algorithm. At each super-iteration <m:math overflow="scroll"><m:mi>r</m:mi></m:math>, the distribution defined as</para>
      <equation id="uid63">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msub>
                    <m:mi>π</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>r</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mi>n</m:mi>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>≜</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mfrac>
                  <m:mrow>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mo>(</m:mo>
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:msub>
                        <m:mi>t</m:mi>
                        <m:mi>r</m:mi>
                      </m:msub>
                    </m:mfrac>
                    <m:mi>ϵ</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mrow>
                    <m:msub>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:msup>
                          <m:mi>z</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>∈</m:mo>
                        <m:msup>
                          <m:mover accent="true">
                            <m:mi>α</m:mi>
                            <m:mo>ˆ</m:mo>
                          </m:mover>
                          <m:mi>n</m:mi>
                        </m:msup>
                      </m:mrow>
                    </m:msub>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:msub>
                          <m:mi>t</m:mi>
                          <m:mi>r</m:mi>
                        </m:msub>
                      </m:mfrac>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>z</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:mfrac>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mfrac>
                    <m:mn>1</m:mn>
                    <m:mrow>
                      <m:msub>
                        <m:mo>∑</m:mo>
                        <m:mrow>
                          <m:msup>
                            <m:mi>z</m:mi>
                            <m:mi>n</m:mi>
                          </m:msup>
                          <m:mo>∈</m:mo>
                          <m:msup>
                            <m:mover accent="true">
                              <m:mi>α</m:mi>
                              <m:mo>ˆ</m:mo>
                            </m:mover>
                            <m:mi>n</m:mi>
                          </m:msup>
                        </m:mrow>
                      </m:msub>
                      <m:mo form="prefix">exp</m:mo>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mo>-</m:mo>
                        <m:mfrac>
                          <m:mn>1</m:mn>
                          <m:msub>
                            <m:mi>t</m:mi>
                            <m:mi>r</m:mi>
                          </m:msub>
                        </m:mfrac>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>ϵ</m:mi>
                          <m:mrow>
                            <m:mo>(</m:mo>
                            <m:msup>
                              <m:mi>z</m:mi>
                              <m:mi>n</m:mi>
                            </m:msup>
                            <m:mo>)</m:mo>
                          </m:mrow>
                          <m:mo>-</m:mo>
                          <m:mi>ϵ</m:mi>
                          <m:mrow>
                            <m:mo>(</m:mo>
                            <m:msup>
                              <m:mi>w</m:mi>
                              <m:mi>n</m:mi>
                            </m:msup>
                            <m:mo>)</m:mo>
                          </m:mrow>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:mrow>
                  </m:mfrac>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id74143">satisfies <m:math overflow="scroll"><m:mrow><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:msub><m:mi>P</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub></m:mrow></m:math>. We can show that the distribution <m:math overflow="scroll"><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub></m:math> converges to a uniform distribution over the set of sequences that minimize the energy function, i.e.,</para>
      <equation id="uid64">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">lim</m:mo>
                    <m:mrow>
                      <m:mi>r</m:mi>
                      <m:mo>→</m:mo>
                      <m:mi>∞</m:mi>
                    </m:mrow>
                  </m:munder>
                  <m:msub>
                    <m:mi>π</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>r</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mi>n</m:mi>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:mfenced separators="" open="{" close="">
                    <m:mtable>
                      <m:mtr>
                        <m:mtd>
                          <m:mn>0</m:mn>
                        </m:mtd>
                        <m:mtd columnalign="left">
                          <m:mrow>
                            <m:msup>
                              <m:mi>w</m:mi>
                              <m:mi>n</m:mi>
                            </m:msup>
                            <m:mo>∉</m:mo>
                            <m:mi mathvariant="script">H</m:mi>
                            <m:mo>,</m:mo>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                      <m:mtr>
                        <m:mtd>
                          <m:mfrac>
                            <m:mn>1</m:mn>
                            <m:mrow>
                              <m:mo>|</m:mo>
                              <m:mi mathvariant="script">H</m:mi>
                              <m:mo>|</m:mo>
                            </m:mrow>
                          </m:mfrac>
                        </m:mtd>
                        <m:mtd columnalign="left">
                          <m:mrow>
                            <m:msup>
                              <m:mi>w</m:mi>
                              <m:mi>n</m:mi>
                            </m:msup>
                            <m:mo>∈</m:mo>
                            <m:mi mathvariant="script">H</m:mi>
                            <m:mo>,</m:mo>
                          </m:mrow>
                        </m:mtd>
                      </m:mtr>
                    </m:mtable>
                  </m:mfenced>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id74356">
where <m:math overflow="scroll"><m:mrow><m:mi mathvariant="script">H</m:mi><m:mo>=</m:mo><m:mo>{</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:msup><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>n</m:mi></m:msup><m:mspace width="3.33333pt"/><m:mi mathvariant="normal">s</m:mi><m:mo>.</m:mo><m:mi mathvariant="normal">t</m:mi><m:mo>.</m:mo><m:mspace width="3.33333pt"/><m:mi>ϵ</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msub><m:mo movablelimits="true" form="prefix">min</m:mo><m:mrow><m:msup><m:mi>z</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:msup><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>n</m:mi></m:msup></m:mrow></m:msub><m:mi>ϵ</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>z</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow><m:mo>}</m:mo></m:mrow></m:math>.
To show <link target-id="uid64"/>, we will show that <m:math overflow="scroll"><m:mrow><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow></m:mrow></m:math> is increasing for <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:mi mathvariant="script">H</m:mi></m:mrow></m:math> and eventually decreasing for <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:msup><m:mi mathvariant="script">H</m:mi><m:mi>C</m:mi></m:msup></m:mrow></m:math>.
Since for <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:mi mathvariant="script">H</m:mi></m:mrow></m:math> and <m:math overflow="scroll"><m:mrow><m:msup><m:mi>z</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:msup><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>n</m:mi></m:msup></m:mrow></m:math>, <m:math overflow="scroll"><m:mrow><m:mi>ϵ</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>z</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow><m:mo>-</m:mo><m:mi>ϵ</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow><m:mo>≥</m:mo><m:mn>0</m:mn></m:mrow></m:math>, and so for <m:math overflow="scroll"><m:mrow><m:msub><m:mi>r</m:mi><m:mn>1</m:mn></m:msub><m:mo>&lt;</m:mo><m:msub><m:mi>r</m:mi><m:mn>2</m:mn></m:msub></m:mrow></m:math> we have</para>
      <equation id="uid65">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>z</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>∈</m:mo>
                      <m:msup>
                        <m:mover accent="true">
                          <m:mi>α</m:mi>
                          <m:mo>ˆ</m:mo>
                        </m:mover>
                        <m:mi>n</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:munder>
                  <m:mo form="prefix">exp</m:mo>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:msub>
                        <m:mi>t</m:mi>
                        <m:msub>
                          <m:mi>r</m:mi>
                          <m:mn>1</m:mn>
                        </m:msub>
                      </m:msub>
                    </m:mfrac>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>z</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>-</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>w</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≥</m:mo>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>∈</m:mo>
                      <m:msup>
                        <m:mover accent="true">
                          <m:mi>α</m:mi>
                          <m:mo>ˆ</m:mo>
                        </m:mover>
                        <m:mi>n</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:munder>
                  <m:mo form="prefix">exp</m:mo>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:msub>
                        <m:mi>t</m:mi>
                        <m:msub>
                          <m:mi>r</m:mi>
                          <m:mn>2</m:mn>
                        </m:msub>
                      </m:msub>
                    </m:mfrac>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>z</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>-</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>w</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>,</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id74926">
which together with <link target-id="uid63"/> implies <m:math overflow="scroll"><m:mrow><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mi>r</m:mi><m:mn>1</m:mn></m:msub><m:mo>)</m:mo></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow><m:mo>≤</m:mo><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mi>r</m:mi><m:mn>2</m:mn></m:msub><m:mo>)</m:mo></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow></m:mrow></m:math>. On the other hand, if <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>∉</m:mo><m:mi mathvariant="script">H</m:mi></m:mrow></m:math>, then</para>
      <equation id="uid66">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd/>
              <m:mtd/>
              <m:mtd columnalign="left">
                <m:mfrac>
                  <m:mn>1</m:mn>
                  <m:mrow>
                    <m:msub>
                      <m:mi>π</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>r</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:mfrac>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>z</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>:</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>z</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>≥</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>w</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:mrow>
                  </m:munder>
                  <m:mo form="prefix">exp</m:mo>
                  <m:mfenced separators="" open="{" close="}">
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:msub>
                        <m:mi>t</m:mi>
                        <m:mi>r</m:mi>
                      </m:msub>
                    </m:mfrac>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>z</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>-</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>w</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:mfenced>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>+</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>z</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>:</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>z</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>&lt;</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>w</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:mrow>
                  </m:munder>
                  <m:mo form="prefix">exp</m:mo>
                  <m:mfenced separators="" open="{" close="}">
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:msub>
                        <m:mi>t</m:mi>
                        <m:mi>r</m:mi>
                      </m:msub>
                    </m:mfrac>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>z</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>-</m:mo>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>y</m:mi>
                          <m:mi>n</m:mi>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:mfenced>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id75333">For sufficiently small <m:math overflow="scroll"><m:mi>t</m:mi></m:math>, the right hand side (more precisely, the second and third lines)
of <link target-id="uid66"/> is dominated by the second term (third line), which increases when <m:math overflow="scroll"><m:mi>t</m:mi></m:math> decreases, and therefore <m:math overflow="scroll"><m:mrow><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow></m:mrow></m:math> decreases for <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:mi mathvariant="script">H</m:mi></m:mrow></m:math> as <m:math overflow="scroll"><m:mi>t</m:mi></m:math> increases. Finally, since all sequences <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:mi mathvariant="script">H</m:mi></m:mrow></m:math> have the same energy <m:math overflow="scroll"><m:mrow><m:mi>ϵ</m:mi><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow></m:math>, it follows that the distribution is uniform over the symbols in <m:math overflow="scroll"><m:mi mathvariant="script">H</m:mi></m:math>.</para>
      <para id="id75482">Having shown convergence of the non-homogenous Markov chain's stable state distributions, we now show that the non-homogeneous MC is strongly ergodic. The transition matrix <m:math overflow="scroll"><m:msub><m:mi>P</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub></m:math> of the MC at iteration <m:math overflow="scroll"><m:mi>t</m:mi></m:math> depends on the temperature <m:math overflow="scroll"><m:mi>t</m:mi></m:math> used within MCMC algorithm. We first show that the MC used in the MCMC algorithm is weakly ergodic via <link target-id="id73448">Theorem 11</link>; the proof of the following Lemma is given at the end of this section.</para><para id="id75531"><emphasis effect="bold">Lemma 2</emphasis> The ergodic coefficient of <m:math overflow="scroll"><m:msub><m:mi>P</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub></m:math> for any <m:math overflow="scroll"><m:mrow><m:mi>r</m:mi><m:mo>≥</m:mo><m:mn>0</m:mn></m:mrow></m:math> is upper bounded by</para><equation id="uid68">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mi>δ</m:mi>
                  <m:mfenced separators="" open="(" close=")">
                    <m:msub>
                      <m:mi>P</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>r</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                  </m:mfenced>
                  <m:mo>≤</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>-</m:mo>
                  <m:mo form="prefix">exp</m:mo>
                  <m:mfenced separators="" open="{" close="}">
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:msub>
                        <m:mi>t</m:mi>
                        <m:mi>r</m:mi>
                      </m:msub>
                    </m:mfrac>
                    <m:mi>n</m:mi>
                    <m:msub>
                      <m:mi>Δ</m:mi>
                      <m:mi>k</m:mi>
                    </m:msub>
                  </m:mfenced>
                  <m:mo>,</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id75666">
where <m:math overflow="scroll"><m:msub><m:mi>Δ</m:mi><m:mi>k</m:mi></m:msub></m:math> is defined in <link target-id="uid10"/>.</para>
      <para id="id75697">Let <m:math overflow="scroll"><m:mrow><m:msubsup><m:mi>w</m:mi><m:mn>1</m:mn><m:mi>n</m:mi></m:msubsup><m:mo>,</m:mo><m:msubsup><m:mi>w</m:mi><m:mn>2</m:mn><m:mi>n</m:mi></m:msubsup></m:mrow></m:math> be two arbitrary sequences in <m:math overflow="scroll"><m:msup><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover><m:mi>n</m:mi></m:msup></m:math>. The probability of transitioning from a given state to a neighboring state in an iteration within iteration <m:math overflow="scroll"><m:msup><m:mi>r</m:mi><m:mo>'</m:mo></m:msup></m:math> of super iteration <m:math overflow="scroll"><m:mi>r</m:mi></m:math> of the MCMC algorithm is given by <link target-id="uid9"/>, and can be rewritten as</para>
      <equation id="id75783">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msub>
                    <m:mi>P</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>r</m:mi>
                      <m:mo>,</m:mo>
                      <m:msup>
                        <m:mi>r</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>w</m:mi>
                      <m:msup>
                        <m:mi>r</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                    </m:msub>
                    <m:mo>=</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>|</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mrow>
                        <m:mi>n</m:mi>
                        <m:mo>∖</m:mo>
                        <m:msup>
                          <m:mi>r</m:mi>
                          <m:mo>'</m:mo>
                        </m:msup>
                      </m:mrow>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mo form="prefix">Pr</m:mo>
                  <m:mo>(</m:mo>
                  <m:msub>
                    <m:mi>w</m:mi>
                    <m:msup>
                      <m:mi>r</m:mi>
                      <m:mo>'</m:mo>
                    </m:msup>
                  </m:msub>
                  <m:mo>=</m:mo>
                  <m:mi>b</m:mi>
                  <m:mo>|</m:mo>
                  <m:msup>
                    <m:mi>w</m:mi>
                    <m:mrow>
                      <m:mrow>
                        <m:mi>n</m:mi>
                        <m:mo>∖</m:mo>
                      </m:mrow>
                      <m:msup>
                        <m:mi>r</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                    </m:mrow>
                  </m:msup>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mfrac>
                  <m:mrow>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mfenced separators="" open="{" close="}">
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:msub>
                          <m:mi>t</m:mi>
                          <m:mi>r</m:mi>
                        </m:msub>
                      </m:mfrac>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msub>
                          <m:mi>w</m:mi>
                          <m:msup>
                            <m:mi>r</m:mi>
                            <m:mo>'</m:mo>
                          </m:msup>
                        </m:msub>
                        <m:mo>=</m:mo>
                        <m:mi>b</m:mi>
                        <m:mo>,</m:mo>
                        <m:msup>
                          <m:mi>w</m:mi>
                          <m:mrow>
                            <m:mrow>
                              <m:mi>n</m:mi>
                              <m:mo>∖</m:mo>
                            </m:mrow>
                            <m:msup>
                              <m:mi>r</m:mi>
                              <m:mo>'</m:mo>
                            </m:msup>
                          </m:mrow>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:mfenced>
                  </m:mrow>
                  <m:mrow>
                    <m:msub>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:msup>
                          <m:mi>b</m:mi>
                          <m:mo>'</m:mo>
                        </m:msup>
                        <m:mo>∈</m:mo>
                        <m:mover accent="true">
                          <m:mi>α</m:mi>
                          <m:mo>ˆ</m:mo>
                        </m:mover>
                      </m:mrow>
                    </m:msub>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mfenced separators="" open="(" close=")">
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:msub>
                          <m:mi>t</m:mi>
                          <m:mi>r</m:mi>
                        </m:msub>
                      </m:mfrac>
                      <m:mi>ϵ</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msub>
                          <m:mi>w</m:mi>
                          <m:msup>
                            <m:mi>r</m:mi>
                            <m:mo>'</m:mo>
                          </m:msup>
                        </m:msub>
                        <m:mo>=</m:mo>
                        <m:msup>
                          <m:mi>b</m:mi>
                          <m:mo>'</m:mo>
                        </m:msup>
                        <m:mo>,</m:mo>
                        <m:msup>
                          <m:mi>w</m:mi>
                          <m:mrow>
                            <m:mrow>
                              <m:mi>n</m:mi>
                              <m:mo>∖</m:mo>
                            </m:mrow>
                            <m:msup>
                              <m:mi>r</m:mi>
                              <m:mo>'</m:mo>
                            </m:msup>
                          </m:mrow>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:mfenced>
                  </m:mrow>
                </m:mfrac>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mfrac>
                  <m:mrow>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mfenced separators="" open="(" close=")">
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:mi>t</m:mi>
                      </m:mfrac>
                      <m:mfenced separators="" open="(" close=")">
                        <m:mi>ϵ</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msubsup>
                            <m:mi>w</m:mi>
                            <m:mn>1</m:mn>
                            <m:mrow>
                              <m:msup>
                                <m:mi>r</m:mi>
                                <m:mo>'</m:mo>
                              </m:msup>
                              <m:mo>-</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:msubsup>
                          <m:mi>b</m:mi>
                          <m:msubsup>
                            <m:mi>w</m:mi>
                            <m:mrow>
                              <m:msup>
                                <m:mi>r</m:mi>
                                <m:mo>'</m:mo>
                              </m:msup>
                              <m:mo>+</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                            <m:mi>n</m:mi>
                          </m:msubsup>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>-</m:mo>
                        <m:msub>
                          <m:mi>ϵ</m:mi>
                          <m:mrow>
                            <m:mo movablelimits="true" form="prefix">min</m:mo>
                            <m:mo>,</m:mo>
                            <m:msup>
                              <m:mi>r</m:mi>
                              <m:mo>'</m:mo>
                            </m:msup>
                          </m:mrow>
                        </m:msub>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msubsup>
                            <m:mi>w</m:mi>
                            <m:mn>1</m:mn>
                            <m:mrow>
                              <m:msup>
                                <m:mi>r</m:mi>
                                <m:mo>'</m:mo>
                              </m:msup>
                              <m:mo>-</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:msubsup>
                          <m:mo>,</m:mo>
                          <m:msubsup>
                            <m:mi>w</m:mi>
                            <m:mrow>
                              <m:msup>
                                <m:mi>r</m:mi>
                                <m:mo>'</m:mo>
                              </m:msup>
                              <m:mo>+</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                            <m:mi>n</m:mi>
                          </m:msubsup>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:mfenced>
                    </m:mfenced>
                  </m:mrow>
                  <m:mrow>
                    <m:msub>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:msup>
                          <m:mi>b</m:mi>
                          <m:mo>'</m:mo>
                        </m:msup>
                        <m:mo>∈</m:mo>
                        <m:mover accent="true">
                          <m:mi>α</m:mi>
                          <m:mo>ˆ</m:mo>
                        </m:mover>
                      </m:mrow>
                    </m:msub>
                    <m:mo form="prefix">exp</m:mo>
                    <m:mfenced separators="" open="(" close=")">
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:mi>t</m:mi>
                      </m:mfrac>
                      <m:mfenced separators="" open="(" close=")">
                        <m:mi>ϵ</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msubsup>
                            <m:mi>w</m:mi>
                            <m:mn>1</m:mn>
                            <m:mrow>
                              <m:msup>
                                <m:mi>r</m:mi>
                                <m:mo>'</m:mo>
                              </m:msup>
                              <m:mo>-</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:msubsup>
                          <m:msup>
                            <m:mi>b</m:mi>
                            <m:mo>'</m:mo>
                          </m:msup>
                          <m:msubsup>
                            <m:mi>w</m:mi>
                            <m:mrow>
                              <m:msup>
                                <m:mi>r</m:mi>
                                <m:mo>'</m:mo>
                              </m:msup>
                              <m:mo>+</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                            <m:mi>n</m:mi>
                          </m:msubsup>
                          <m:mo>)</m:mo>
                        </m:mrow>
                        <m:mo>-</m:mo>
                        <m:msub>
                          <m:mi>ϵ</m:mi>
                          <m:mrow>
                            <m:mo movablelimits="true" form="prefix">min</m:mo>
                            <m:mo>,</m:mo>
                            <m:msup>
                              <m:mi>r</m:mi>
                              <m:mo>'</m:mo>
                            </m:msup>
                          </m:mrow>
                        </m:msub>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msubsup>
                            <m:mi>w</m:mi>
                            <m:mn>1</m:mn>
                            <m:mrow>
                              <m:msup>
                                <m:mi>r</m:mi>
                                <m:mo>'</m:mo>
                              </m:msup>
                              <m:mo>-</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:msubsup>
                          <m:mo>,</m:mo>
                          <m:msubsup>
                            <m:mi>w</m:mi>
                            <m:mrow>
                              <m:msup>
                                <m:mi>r</m:mi>
                                <m:mo>'</m:mo>
                              </m:msup>
                              <m:mo>+</m:mo>
                              <m:mn>1</m:mn>
                            </m:mrow>
                            <m:mi>n</m:mi>
                          </m:msubsup>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:mfenced>
                    </m:mfenced>
                  </m:mrow>
                </m:mfrac>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>≥</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mfrac>
                    <m:mrow>
                      <m:mo form="prefix">exp</m:mo>
                      <m:mo>(</m:mo>
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:mi>t</m:mi>
                      </m:mfrac>
                      <m:msub>
                        <m:mi>Δ</m:mi>
                        <m:mi>k</m:mi>
                      </m:msub>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mrow>
                      <m:mrow>
                        <m:mo>|</m:mo>
                      </m:mrow>
                      <m:mover accent="true">
                        <m:mi>α</m:mi>
                        <m:mo>ˆ</m:mo>
                      </m:mover>
                      <m:mrow>
                        <m:mo>|</m:mo>
                      </m:mrow>
                    </m:mrow>
                  </m:mfrac>
                  <m:mo>,</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id76525">where <m:math overflow="scroll"><m:mrow><m:msub><m:mi>ϵ</m:mi><m:mrow><m:mo movablelimits="true" form="prefix">min</m:mo><m:mo>,</m:mo><m:msup><m:mi>r</m:mi><m:mo>'</m:mo></m:msup></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:msubsup><m:mi>w</m:mi><m:mn>1</m:mn><m:mrow><m:msup><m:mi>r</m:mi><m:mo>'</m:mo></m:msup><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msubsup><m:mi>b</m:mi><m:msubsup><m:mi>w</m:mi><m:mrow><m:msup><m:mi>r</m:mi><m:mo>'</m:mo></m:msup><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow><m:mi>n</m:mi></m:msubsup><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msub><m:mo movablelimits="true" form="prefix">min</m:mo><m:mrow><m:msup><m:mi>b</m:mi><m:mo>'</m:mo></m:msup><m:mo>∈</m:mo><m:mover accent="true"><m:mi>α</m:mi><m:mo>ˆ</m:mo></m:mover></m:mrow></m:msub><m:mi>ϵ</m:mi><m:mrow><m:mo>(</m:mo><m:msubsup><m:mi>w</m:mi><m:mn>1</m:mn><m:mrow><m:msup><m:mi>r</m:mi><m:mo>'</m:mo></m:msup><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msubsup><m:msup><m:mi>b</m:mi><m:mo>'</m:mo></m:msup><m:msubsup><m:mi>w</m:mi><m:mrow><m:msup><m:mi>r</m:mi><m:mo>'</m:mo></m:msup><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow><m:mi>n</m:mi></m:msubsup><m:mo>)</m:mo></m:mrow></m:mrow></m:math>.
Therefore the smallest probability of transition from <m:math overflow="scroll"><m:msubsup><m:mi>w</m:mi><m:mn>1</m:mn><m:mi>n</m:mi></m:msubsup></m:math> to <m:math overflow="scroll"><m:msubsup><m:mi>w</m:mi><m:mn>2</m:mn><m:mi>n</m:mi></m:msubsup></m:math> within super-iteration <m:math overflow="scroll"><m:mi>r</m:mi></m:math> is bounded by</para>
      <equation id="uid69">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">min</m:mo>
                    <m:mrow>
                      <m:msubsup>
                        <m:mi>w</m:mi>
                        <m:mn>1</m:mn>
                        <m:mi>n</m:mi>
                      </m:msubsup>
                      <m:mo>,</m:mo>
                      <m:msubsup>
                        <m:mi>w</m:mi>
                        <m:mn>2</m:mn>
                        <m:mi>n</m:mi>
                      </m:msubsup>
                      <m:mo>∈</m:mo>
                      <m:msup>
                        <m:mover accent="true">
                          <m:mi>α</m:mi>
                          <m:mo>ˆ</m:mo>
                        </m:mover>
                        <m:mi>n</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:munder>
                  <m:msub>
                    <m:mi>P</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>r</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msubsup>
                      <m:mi>w</m:mi>
                      <m:mn>2</m:mn>
                      <m:mi>n</m:mi>
                    </m:msubsup>
                    <m:mo>|</m:mo>
                    <m:msubsup>
                      <m:mi>w</m:mi>
                      <m:mn>1</m:mn>
                      <m:mi>n</m:mi>
                    </m:msubsup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mo>≥</m:mo>
                  <m:munderover>
                    <m:mo>∏</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>r</m:mi>
                        <m:mo>'</m:mo>
                      </m:msup>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>n</m:mi>
                  </m:munderover>
                  <m:mfrac>
                    <m:mrow>
                      <m:mo form="prefix">exp</m:mo>
                      <m:mo>(</m:mo>
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:msub>
                          <m:mi>t</m:mi>
                          <m:mi>r</m:mi>
                        </m:msub>
                      </m:mfrac>
                      <m:msub>
                        <m:mi>Δ</m:mi>
                        <m:mi>k</m:mi>
                      </m:msub>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mrow>
                      <m:mrow>
                        <m:mo>|</m:mo>
                      </m:mrow>
                      <m:mover accent="true">
                        <m:mi>α</m:mi>
                        <m:mo>ˆ</m:mo>
                      </m:mover>
                      <m:mrow>
                        <m:mo>|</m:mo>
                      </m:mrow>
                    </m:mrow>
                  </m:mfrac>
                  <m:mo>=</m:mo>
                  <m:mfrac>
                    <m:mrow>
                      <m:mo form="prefix">exp</m:mo>
                      <m:mo>(</m:mo>
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:msub>
                          <m:mi>t</m:mi>
                          <m:mi>r</m:mi>
                        </m:msub>
                      </m:mfrac>
                      <m:mi>n</m:mi>
                      <m:msub>
                        <m:mi>Δ</m:mi>
                        <m:mi>k</m:mi>
                      </m:msub>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mrow>
                      <m:mrow>
                        <m:mo>|</m:mo>
                      </m:mrow>
                      <m:mover accent="true">
                        <m:mi>α</m:mi>
                        <m:mo>ˆ</m:mo>
                      </m:mover>
                      <m:msup>
                        <m:mrow>
                          <m:mo>|</m:mo>
                        </m:mrow>
                        <m:mi>n</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mfrac>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id77002">
Using the alternative definition of the ergodic coefficient given in <link target-id="uid55"/>,</para>
      <equation id="uid70">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mi>δ</m:mi>
                  <m:mfenced separators="" open="(" close=")">
                    <m:msub>
                      <m:mi>P</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>r</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                  </m:mfenced>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>-</m:mo>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">min</m:mo>
                    <m:mrow>
                      <m:msubsup>
                        <m:mi>w</m:mi>
                        <m:mn>1</m:mn>
                        <m:mi>n</m:mi>
                      </m:msubsup>
                      <m:mo>,</m:mo>
                      <m:msubsup>
                        <m:mi>w</m:mi>
                        <m:mn>2</m:mn>
                        <m:mi>n</m:mi>
                      </m:msubsup>
                      <m:mo>∈</m:mo>
                      <m:msup>
                        <m:mover accent="true">
                          <m:mi>α</m:mi>
                          <m:mo>ˆ</m:mo>
                        </m:mover>
                        <m:mi>n</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:munder>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>z</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>∈</m:mo>
                      <m:msup>
                        <m:mover accent="true">
                          <m:mi>α</m:mi>
                          <m:mo>ˆ</m:mo>
                        </m:mover>
                        <m:mi>n</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:munder>
                  <m:mo movablelimits="true" form="prefix">min</m:mo>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>P</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>r</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>z</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>|</m:mo>
                      <m:msubsup>
                        <m:mi>w</m:mi>
                        <m:mn>1</m:mn>
                        <m:mi>n</m:mi>
                      </m:msubsup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>,</m:mo>
                    <m:msub>
                      <m:mi>P</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>r</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>z</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>|</m:mo>
                      <m:msubsup>
                        <m:mi>w</m:mi>
                        <m:mn>2</m:mn>
                        <m:mi>n</m:mi>
                      </m:msubsup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mrow>
                    <m:mo>≤</m:mo>
                    <m:mn>1</m:mn>
                    <m:mo>-</m:mo>
                    <m:mo>|</m:mo>
                  </m:mrow>
                  <m:mover accent="true">
                    <m:mi>α</m:mi>
                    <m:mo>ˆ</m:mo>
                  </m:mover>
                  <m:msup>
                    <m:mrow>
                      <m:mo>|</m:mo>
                    </m:mrow>
                    <m:mi>n</m:mi>
                  </m:msup>
                  <m:mfrac>
                    <m:mrow>
                      <m:mo form="prefix">exp</m:mo>
                      <m:mo>(</m:mo>
                      <m:mo>-</m:mo>
                      <m:mfrac>
                        <m:mn>1</m:mn>
                        <m:msub>
                          <m:mi>t</m:mi>
                          <m:mi>r</m:mi>
                        </m:msub>
                      </m:mfrac>
                      <m:mi>n</m:mi>
                      <m:msub>
                        <m:mi>Δ</m:mi>
                        <m:mi>k</m:mi>
                      </m:msub>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mrow>
                      <m:mrow>
                        <m:mo>|</m:mo>
                      </m:mrow>
                      <m:mover accent="true">
                        <m:mi>α</m:mi>
                        <m:mo>ˆ</m:mo>
                      </m:mover>
                      <m:msup>
                        <m:mrow>
                          <m:mo>|</m:mo>
                        </m:mrow>
                        <m:mi>n</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mfrac>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>-</m:mo>
                  <m:mo form="prefix">exp</m:mo>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:msub>
                        <m:mi>t</m:mi>
                        <m:mi>r</m:mi>
                      </m:msub>
                    </m:mfrac>
                    <m:mi>n</m:mi>
                    <m:msub>
                      <m:mi>Δ</m:mi>
                      <m:mi>k</m:mi>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id77375">Using <link target-id="id75531">Lemma 2</link>, we can evaluate the sum given in <link target-id="id73448">Theorem 11</link> as</para><equation id="id77388">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>r</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>∞</m:mi>
                  </m:munderover>
                  <m:mfenced separators="" open="(" close=")">
                    <m:mn>1</m:mn>
                    <m:mo>-</m:mo>
                    <m:mi>δ</m:mi>
                    <m:mfenced separators="" open="(" close=")">
                      <m:msub>
                        <m:mi>P</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>r</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                    </m:mfenced>
                  </m:mfenced>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>≥</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>r</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>∞</m:mi>
                  </m:munderover>
                  <m:mo form="prefix">exp</m:mo>
                  <m:mfenced separators="" open="(" close=")">
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:msub>
                        <m:mi>t</m:mi>
                        <m:mi>r</m:mi>
                      </m:msub>
                    </m:mfrac>
                    <m:mi>n</m:mi>
                    <m:msub>
                      <m:mi>Δ</m:mi>
                      <m:mi>k</m:mi>
                    </m:msub>
                  </m:mfenced>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>r</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>∞</m:mi>
                  </m:munderover>
                  <m:mfrac>
                    <m:mn>1</m:mn>
                    <m:msup>
                      <m:mi>r</m:mi>
                      <m:mrow>
                        <m:mn>1</m:mn>
                        <m:mo>/</m:mo>
                        <m:mi>c</m:mi>
                      </m:mrow>
                    </m:msup>
                  </m:mfrac>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mi>∞</m:mi>
                  <m:mo>,</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id77573">and therefore the non-homogeneous MC defined by <m:math overflow="scroll"><m:msubsup><m:mrow><m:mo>{</m:mo><m:msub><m:mi>P</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:mo>}</m:mo></m:mrow><m:mrow><m:mi>r</m:mi><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow><m:mi>∞</m:mi></m:msubsup></m:math> is weakly ergodic. Now we can use <link target-id="id73600">Theorem 12</link> to show that the MC is strongly ergodic by proving that</para><equation id="uid71">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>r</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>∞</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mrow>
                      <m:mo>∥</m:mo>
                      <m:msub>
                        <m:mi>π</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>r</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                      <m:mo>-</m:mo>
                      <m:msub>
                        <m:mi>π</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>r</m:mi>
                          <m:mo>+</m:mo>
                          <m:mn>1</m:mn>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                      <m:mo>∥</m:mo>
                    </m:mrow>
                    <m:mn>1</m:mn>
                  </m:msub>
                  <m:mo>&lt;</m:mo>
                  <m:mi>∞</m:mi>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id77713">
Since we know from earlier in the proof that <m:math overflow="scroll"><m:mrow><m:msub><m:mi>π</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>)</m:mo></m:mrow></m:mrow></m:math> is increasing for <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:mi mathvariant="script">H</m:mi></m:mrow></m:math> and eventually decreasing for <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>n</m:mi></m:msup><m:mo>∈</m:mo><m:msup><m:mi mathvariant="script">H</m:mi><m:mi>C</m:mi></m:msup></m:mrow></m:math>, there exists a <m:math overflow="scroll"><m:mrow><m:msub><m:mi>r</m:mi><m:mn>0</m:mn></m:msub><m:mo>∈</m:mo><m:mi mathvariant="double-struck">N</m:mi></m:mrow></m:math> such that for any <m:math overflow="scroll"><m:mrow><m:msub><m:mi>r</m:mi><m:mn>1</m:mn></m:msub><m:mo>&gt;</m:mo><m:msub><m:mi>r</m:mi><m:mn>0</m:mn></m:msub></m:mrow></m:math>,</para>
      <equation id="id77850">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>r</m:mi>
                      <m:mo>=</m:mo>
                      <m:msub>
                        <m:mi>r</m:mi>
                        <m:mn>0</m:mn>
                      </m:msub>
                    </m:mrow>
                    <m:msub>
                      <m:mi>r</m:mi>
                      <m:mn>1</m:mn>
                    </m:msub>
                  </m:munderover>
                  <m:msub>
                    <m:mrow>
                      <m:mo>∥</m:mo>
                      <m:msub>
                        <m:mi>π</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>r</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                      <m:mo>-</m:mo>
                      <m:msub>
                        <m:mi>π</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>r</m:mi>
                          <m:mo>+</m:mo>
                          <m:mn>1</m:mn>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                      <m:mo>∥</m:mo>
                    </m:mrow>
                    <m:mn>1</m:mn>
                  </m:msub>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>∈</m:mo>
                      <m:mi mathvariant="script">H</m:mi>
                    </m:mrow>
                  </m:munder>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>r</m:mi>
                      <m:mo>=</m:mo>
                      <m:msub>
                        <m:mi>r</m:mi>
                        <m:mn>0</m:mn>
                      </m:msub>
                    </m:mrow>
                    <m:msub>
                      <m:mi>r</m:mi>
                      <m:mn>1</m:mn>
                    </m:msub>
                  </m:munderover>
                  <m:mfenced separators="" open="(" close=")">
                    <m:msub>
                      <m:mi>π</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>r</m:mi>
                        <m:mo>+</m:mo>
                        <m:mn>1</m:mn>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>-</m:mo>
                    <m:msub>
                      <m:mi>π</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>r</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:mfenced>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>+</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>∉</m:mo>
                      <m:mi mathvariant="script">H</m:mi>
                    </m:mrow>
                  </m:munder>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>r</m:mi>
                      <m:mo>=</m:mo>
                      <m:msub>
                        <m:mi>r</m:mi>
                        <m:mn>0</m:mn>
                      </m:msub>
                    </m:mrow>
                    <m:msub>
                      <m:mi>r</m:mi>
                      <m:mn>1</m:mn>
                    </m:msub>
                  </m:munderover>
                  <m:mfenced separators="" open="(" close=")">
                    <m:msub>
                      <m:mi>π</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>r</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>-</m:mo>
                    <m:msub>
                      <m:mi>π</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>r</m:mi>
                        <m:mo>+</m:mo>
                        <m:mn>1</m:mn>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:mfenced>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>∈</m:mo>
                      <m:mi mathvariant="script">H</m:mi>
                    </m:mrow>
                  </m:munder>
                  <m:mfenced separators="" open="(" close=")">
                    <m:msub>
                      <m:mi>π</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msub>
                          <m:mi>r</m:mi>
                          <m:mn>1</m:mn>
                        </m:msub>
                        <m:mo>+</m:mo>
                        <m:mn>1</m:mn>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>-</m:mo>
                    <m:msub>
                      <m:mi>π</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msub>
                          <m:mi>r</m:mi>
                          <m:mn>0</m:mn>
                        </m:msub>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:mfenced>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>+</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>∉</m:mo>
                      <m:mi mathvariant="script">H</m:mi>
                    </m:mrow>
                  </m:munder>
                  <m:mfenced separators="" open="(" close=")">
                    <m:msub>
                      <m:mi>π</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msub>
                          <m:mi>r</m:mi>
                          <m:mn>0</m:mn>
                        </m:msub>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>-</m:mo>
                    <m:msub>
                      <m:mi>π</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msub>
                          <m:mi>r</m:mi>
                          <m:mn>1</m:mn>
                        </m:msub>
                        <m:mo>+</m:mo>
                        <m:mn>1</m:mn>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msub>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>w</m:mi>
                        <m:mi>n</m:mi>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:mfenced>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mrow>
                    <m:mo>∥</m:mo>
                  </m:mrow>
                  <m:msub>
                    <m:mi>π</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msub>
                        <m:mi>r</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                      <m:mo>+</m:mo>
                      <m:mn>1</m:mn>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msub>
                  <m:mo>-</m:mo>
                  <m:msub>
                    <m:mi>π</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msub>
                        <m:mi>r</m:mi>
                        <m:mn>0</m:mn>
                      </m:msub>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msub>
                  <m:msub>
                    <m:mrow>
                      <m:mo>∥</m:mo>
                    </m:mrow>
                    <m:mn>1</m:mn>
                  </m:msub>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>≤</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mrow>
                    <m:mo>∥</m:mo>
                  </m:mrow>
                  <m:msub>
                    <m:mi>π</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msub>
                        <m:mi>r</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                      <m:mo>+</m:mo>
                      <m:mn>1</m:mn>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msub>
                  <m:msub>
                    <m:mrow>
                      <m:mo>∥</m:mo>
                    </m:mrow>
                    <m:mn>1</m:mn>
                  </m:msub>
                  <m:mo>+</m:mo>
                  <m:msub>
                    <m:mrow>
                      <m:mo>∥</m:mo>
                      <m:msub>
                        <m:mi>π</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:msub>
                            <m:mi>r</m:mi>
                            <m:mn>0</m:mn>
                          </m:msub>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msub>
                      <m:mo>∥</m:mo>
                    </m:mrow>
                    <m:mn>1</m:mn>
                  </m:msub>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mn>2</m:mn>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id78549">Since the right hand side does not depend on <m:math overflow="scroll"><m:msub><m:mi>r</m:mi><m:mn>1</m:mn></m:msub></m:math>,
then we have that</para>
      <equation id="id78570">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>r</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>∞</m:mi>
            </m:munderover>
            <m:msub>
              <m:mrow>
                <m:mo>∥</m:mo>
                <m:msub>
                  <m:mi>π</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>r</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:msub>
                <m:mo>-</m:mo>
                <m:msub>
                  <m:mi>π</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>r</m:mi>
                    <m:mo>+</m:mo>
                    <m:mn>1</m:mn>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:msub>
                <m:mo>∥</m:mo>
              </m:mrow>
              <m:mn>1</m:mn>
            </m:msub>
            <m:mo>&lt;</m:mo>
            <m:mi>∞</m:mi>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id78646">This implies that the non-homogeneous MC used by MCMC algorithm is strongly ergodic, and thus completes the proof of <link target-id="id72162">Theorem 10</link>.</para></section>
  </content>
  <bib:file>
    <bib:entry id="bid22">
      <bib:inproceedings>
        <!--required fields-->
        <bib:author>Baron, D.</bib:author>
        <bib:title>Information complexity and estimation</bib:title>
        <bib:booktitle>Fourth Workshop Inf. Theoretic Methods Science Eng. (WITMSE 2011)</bib:booktitle>
        <bib:year>2011</bib:year>
        <!--optional fields-->
        <bib:editor/>
        <bib:number/>
        <bib:series/>
        <bib:pages/>
        <bib:address/>
        <bib:month>Aug.</bib:month>
        <bib:organization/>
        <bib:publisher/>
        <bib:note/>
      </bib:inproceedings>
    </bib:entry>
    <bib:entry id="bid23">
      <bib:conference>
        <!--required fields-->
        <bib:author>Baron, D. and Duarte, M. F.</bib:author>
        <bib:title>Universal MAP Estimation in Compressed Sensing</bib:title>
        <bib:booktitle>Proc. 49th Annual Allerton Conf. Comm., Control, Computing</bib:booktitle>
        <bib:year>2011</bib:year>
        <!--optional fields-->
        <bib:editor/>
        <bib:number/>
        <bib:series/>
        <bib:pages/>
        <bib:address/>
        <bib:month>Sep.</bib:month>
        <bib:organization/>
        <bib:publisher/>
        <bib:note/>
      </bib:conference>
    </bib:entry>
    <bib:entry id="bid0">
      <bib:book>
        <!--required fields-->
        <bib:author>Berger, T.</bib:author>
        <bib:title>Rate distortion theory; a mathematical basis for data compression</bib:title>
        <bib:publisher>Prentice-Hall Englewood Cliffs, NJ</bib:publisher>
        <bib:year>1971</bib:year>
        <!--optional fields-->
        <bib:volume/>
        <bib:series/>
        <bib:address/>
        <bib:edition/>
        <bib:month/>
        <bib:note/>
      </bib:book>
    </bib:entry>
    <bib:entry id="bid6">
      <bib:article>
        <!--required fields-->
        <bib:author>Buzo, A. and Gray Jr, A. and Gray, R. and Markel, J.</bib:author>
        <bib:title>Speech coding based upon vector quantization</bib:title>
        <bib:journal>IEEE Trans. Acoustics, Speech and Signal Process.</bib:journal>
        <bib:year>1980</bib:year>
        <!--optional fields-->
        <bib:volume>28</bib:volume>
        <bib:number>5</bib:number>
        <bib:pages>562–574</bib:pages>
        <bib:month/>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid24">
      <bib:book>
        <!--required fields-->
        <bib:author>Bramaud, P.</bib:author>
        <bib:title>Markov chains: Gibbs fields, Monte Carlo simulation, and queues</bib:title>
        <bib:publisher>Springer Verlag</bib:publisher>
        <bib:year>1999</bib:year>
        <!--optional fields-->
        <bib:volume>31</bib:volume>
        <bib:series/>
        <bib:address/>
        <bib:edition/>
        <bib:month/>
        <bib:note/>
      </bib:book>
    </bib:entry>
    <bib:entry id="bid11">
      <bib:conference>
        <!--required fields-->
        <bib:author>Baron, D. and Weissman, T.</bib:author>
        <bib:title>An MCMC Approach to Lossy Compression of Continuous Sources</bib:title>
        <bib:booktitle>Proc. Data Compression Conf. (DCC)</bib:booktitle>
        <bib:year>2010</bib:year>
        <!--optional fields-->
        <bib:editor/>
        <bib:number/>
        <bib:series/>
        <bib:pages>40–48</bib:pages>
        <bib:address/>
        <bib:month>Mar.</bib:month>
        <bib:organization/>
        <bib:publisher/>
        <bib:note/>
      </bib:conference>
    </bib:entry>
    <bib:entry id="bid17">
      <bib:article>
        <!--required fields-->
        <bib:author>Chaitin, G. J.</bib:author>
        <bib:title>On the length of programs for computing finite binary sequences</bib:title>
        <bib:journal>J. ACM</bib:journal>
        <bib:year>1966</bib:year>
        <!--optional fields-->
        <bib:volume>13</bib:volume>
        <bib:number>4</bib:number>
        <bib:pages>547–569</bib:pages>
        <bib:month/>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid20">
      <bib:article>
        <!--required fields-->
        <bib:author>Candes, E. and Romberg, J. and Tao, T.</bib:author>
        <bib:title>Robust uncertainty principles: Exact signal reconstruction from highly incomplete frequency information</bib:title>
        <bib:journal>IEEE Trans. Inf. Theory</bib:journal>
        <bib:year>2006</bib:year>
        <!--optional fields-->
        <bib:volume>52</bib:volume>
        <bib:number>2</bib:number>
        <bib:pages>489–509</bib:pages>
        <bib:month>Feb.</bib:month>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid1">
      <bib:book>
        <!--required fields-->
        <bib:author>Cover, T. M. and Thomas, J. A.</bib:author>
        <bib:title>Elements of Information Theory</bib:title>
        <bib:publisher>Wiley-Interscience</bib:publisher>
        <bib:year>2006</bib:year>
        <!--optional fields-->
        <bib:volume/>
        <bib:series/>
        <bib:address/>
        <bib:edition/>
        <bib:month/>
        <bib:note/>
      </bib:book>
    </bib:entry>
    <bib:entry id="bid14">
      <bib:techreport>
        <!--required fields-->
        <bib:author>Donoho, D. L.</bib:author>
        <bib:title>The Kolmogorov Sampler</bib:title>
        <bib:institution>Stanford University</bib:institution>
        <bib:year>2002</bib:year>
        <!--optional fields-->
        <bib:type>Department of Statistics Technical Report</bib:type>
        <bib:number>2002-4</bib:number>
        <bib:address>Stanford, CA</bib:address>
        <bib:month>Jan.</bib:month>
        <bib:note/>
      </bib:techreport>
    </bib:entry>
    <bib:entry id="bid21">
      <bib:article>
        <!--required fields-->
        <bib:author>Donoho, D.</bib:author>
        <bib:title>Compressed sensing</bib:title>
        <bib:journal>IEEE Trans. Inf. Theory</bib:journal>
        <bib:year>2006</bib:year>
        <!--optional fields-->
        <bib:volume>52</bib:volume>
        <bib:number>4</bib:number>
        <bib:pages>1289–1306</bib:pages>
        <bib:month>Apr.</bib:month>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid10">
      <bib:article>
        <!--required fields-->
        <bib:author>Geman, S. and Geman, D.</bib:author>
        <bib:title>Stochastic relaxation, Gibbs distributions, and the Bayesian restoration of images</bib:title>
        <bib:journal>IEEE Trans. Pattern Anal. Mach. Intell.</bib:journal>
        <bib:year>1984</bib:year>
        <!--optional fields-->
        <bib:volume>6</bib:volume>
        <bib:number/>
        <bib:pages>721–741</bib:pages>
        <bib:month>Nov.</bib:month>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid8">
      <bib:inproceedings>
        <!--required fields-->
        <bib:author>Jalali, S. and Weissman, T.</bib:author>
        <bib:title>Rate-distortion via Markov chain Monte Carlo</bib:title>
        <bib:booktitle>Proc. Int. Symp. Inf. Theory (ISIT2008)</bib:booktitle>
        <bib:year>2008</bib:year>
        <!--optional fields-->
        <bib:editor/>
        <bib:number/>
        <bib:series/>
        <bib:pages>852–856</bib:pages>
        <bib:address/>
        <bib:month>Jul.</bib:month>
        <bib:organization/>
        <bib:publisher/>
        <bib:note/>
      </bib:inproceedings>
    </bib:entry>
    <bib:entry id="bid9">
      <bib:article>
        <!--required fields-->
        <bib:author>Jalali, S. and Weissman, T.</bib:author>
        <bib:title>Rate-Distortion via Markov Chain Monte Carlo</bib:title>
        <bib:journal>Arxiv preprint arXiv:0808.4156</bib:journal>
        <bib:year>2008</bib:year>
        <!--optional fields-->
        <bib:volume/>
        <bib:number/>
        <bib:pages/>
        <bib:month/>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid15">
      <bib:article>
        <!--required fields-->
        <bib:author>Kolmogorov, A. N.</bib:author>
        <bib:title>Three approaches to the quantitative definition of information</bib:title>
        <bib:journal>Problems Inf. Transmission</bib:journal>
        <bib:year>1965</bib:year>
        <!--optional fields-->
        <bib:volume>1</bib:volume>
        <bib:number>1</bib:number>
        <bib:pages>1–7</bib:pages>
        <bib:month/>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid3">
      <bib:inproceedings>
        <!--required fields-->
        <bib:author>Lopresto, S. M. and Ramchandran, K. and Orchard, M. T.</bib:author>
        <bib:title>Image coding based on mixture modeling of wavelet coefficients and a fast estimation-quantization framework</bib:title>
        <bib:booktitle>Proc. Data Compression Conf. (DCC)</bib:booktitle>
        <bib:year>1997</bib:year>
        <!--optional fields-->
        <bib:editor/>
        <bib:number/>
        <bib:series/>
        <bib:pages>221–230</bib:pages>
        <bib:address/>
        <bib:month>Mar.</bib:month>
        <bib:organization/>
        <bib:publisher/>
        <bib:note/>
      </bib:inproceedings>
    </bib:entry>
    <bib:entry id="bid19">
      <bib:book>
        <!--required fields-->
        <bib:author>Li, M. and Vitanyi, P. M. B.</bib:author>
        <bib:title>An introduction to Kolmogorov complexity and its applications</bib:title>
        <bib:publisher>Springer-Verlag, New York</bib:publisher>
        <bib:year>2008</bib:year>
        <!--optional fields-->
        <bib:volume/>
        <bib:series/>
        <bib:address/>
        <bib:edition/>
        <bib:month/>
        <bib:note/>
      </bib:book>
    </bib:entry>
    <bib:entry id="bid5">
      <bib:article>
        <!--required fields-->
        <bib:author>Makhoul, J. and Roucos, S. and Gish, H.</bib:author>
        <bib:title>Vector quantization in speech coding</bib:title>
        <bib:journal>Proc. IEEE</bib:journal>
        <bib:year>1985</bib:year>
        <!--optional fields-->
        <bib:volume>73</bib:volume>
        <bib:number>11</bib:number>
        <bib:pages>1551–1588</bib:pages>
        <bib:month>Nov.</bib:month>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid13">
      <bib:article>
        <!--required fields-->
        <bib:author>Rose, K.</bib:author>
        <bib:title>A mapping approach to rate-distortion computation and analysis</bib:title>
        <bib:journal>IEEE Trans. Inf. Theory</bib:journal>
        <bib:year>1994</bib:year>
        <!--optional fields-->
        <bib:volume>40</bib:volume>
        <bib:number>6</bib:number>
        <bib:pages>1939–1952</bib:pages>
        <bib:month>Nov.</bib:month>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid7">
      <bib:article>
        <!--required fields-->
        <bib:author>Sabin, M. and Gray, R.</bib:author>
        <bib:title>Product code vector quantizers for waveform and voice coding</bib:title>
        <bib:journal>IEEE Trans. Acoustics, Speech and Signal Process.</bib:journal>
        <bib:year>1984</bib:year>
        <!--optional fields-->
        <bib:volume>32</bib:volume>
        <bib:number>3</bib:number>
        <bib:pages>474–488</bib:pages>
        <bib:month/>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid16">
      <bib:article>
        <!--required fields-->
        <bib:author>Solomonoff, R. J.</bib:author>
        <bib:title>A formal theory of inductive inference. Part I</bib:title>
        <bib:journal>Inf. and Control</bib:journal>
        <bib:year>1964</bib:year>
        <!--optional fields-->
        <bib:volume>7</bib:volume>
        <bib:number>1</bib:number>
        <bib:pages>1–22</bib:pages>
        <bib:month/>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid18">
      <bib:article>
        <!--required fields-->
        <bib:author>Turing, A. M.</bib:author>
        <bib:title>Computing machinery and intelligence</bib:title>
        <bib:journal>Mind</bib:journal>
        <bib:year>1950</bib:year>
        <!--optional fields-->
        <bib:volume>59</bib:volume>
        <bib:number>236</bib:number>
        <bib:pages>433–460</bib:pages>
        <bib:month/>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid4">
      <bib:article>
        <!--required fields-->
        <bib:author>Wiegand, T. and Sullivan, G. J. and Bjontegaard, G. and Luthra, A.</bib:author>
        <bib:title>Overview of the H.264/AVC video coding standard</bib:title>
        <bib:journal>IEEE Trans. Circuits Syst. Video Technol.</bib:journal>
        <bib:year>2003</bib:year>
        <!--optional fields-->
        <bib:volume>13</bib:volume>
        <bib:number>7</bib:number>
        <bib:pages>560–576</bib:pages>
        <bib:month>Jul.</bib:month>
        <bib:note/>
      </bib:article>
    </bib:entry>
    <bib:entry id="bid2">
      <bib:article>
        <!--required fields-->
        <bib:author>Xiong, Z. and Ramchandran, K. and Orchard, M. T.</bib:author>
        <bib:title>Space-frequency quantization for wavelet image coding</bib:title>
        <bib:journal>IEEE Trans. Image Process.</bib:journal>
        <bib:year>1997</bib:year>
        <!--optional fields-->
        <bib:volume>6</bib:volume>
        <bib:number>5</bib:number>
        <bib:pages>677–693</bib:pages>
        <bib:month>May</bib:month>
        <bib:note/>
      </bib:article>
    </bib:entry>
  </bib:file>
</document>